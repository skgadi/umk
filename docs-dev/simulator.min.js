var tempModel,TempVal;importScripts("lib.min.js"),importScripts("dependencies/mathjs/math.min.js"),importScripts("dependencies/augmented-json-serialization-functions.js"),onmessage=function(t){if("object"==typeof t.data){let s=Object.keys(t.data);for(let e=0;e<s.length;e++)switch(s[e]){case"cells":exec.setCells(t.data.cells);break;case"updateCell":exec.updCell(t.data.updateCell.v,t.data.updateCell.i);break;case"simSettings":exec.setSimSettings(t.data.simSettings);break;case"start":exec.start();break;case"stop":exec.stop();break;case"pause":exec.pause();break;case"steps":exec.steps()}}else exec.start()};const exec={cells:[],simSettings:{hs:5,h:5e3,T:5,realtime:!0,steps:1,sOEvery:1,pckSize:2e3,it:"fe"},t:0,k:0,s4Out:0,prevT:0,isCont:!0,inPrg:!1,rSteps:0,results:[],setSimSettings:function(t){this.simSettings.hs=t.h/1e3,this.simSettings.h=t.h,this.simSettings.T=t.T<0?1/0:t.T,this.simSettings.realtime=t.realtime,this.simSettings.steps=t.steps,this.simSettings.sOEvery=t.sOEvery-1,this.simSettings.it=t.it,this.pckSize=t.mHis*t.sOEvery,this.s4Out=this.simSettings.sOEvery,this.inPrg&&this.setRemainingSteps()},setParams:function(t){try{if(t.Parameters){let s=Object.keys(t.Parameters);for(let e=0;e<s.length;e++)"Complex"!==t.Parameters[s[e]].Type&&"Real"!==t.Parameters[s[e]].Type&&"Integer"!==t.Parameters[s[e]].Type||(t.Parameters[s[e]].Value=math.evaluate(t.Parameters[s[e]].Value))}t.genCompParams()}catch(t){console.log(t)}},setCells:function(vals){this.cells=vals.map(ele=>(eval("var tempModel = new "+ele.id+"(ele);"),this.setParams(tempModel),tempModel))},updCell:function(value,index){eval("var tempModel = new "+value.id+"(value);"),this.setParams(tempModel),this.cells[index]=tempModel},simulate:function(){let t,s=!1,e={};try{this.s4Out++>=this.simSettings.sOEvery&&(s=!0,this.s4Out=0);for(let s=0;s<this.cells.length;s++){t=this.cells[s];for(let s=0;s<t.TerminalsIn.value;s++)t.inputs[s]=this.cells[t.sIndexes[s].cell].outputs[t.sIndexes[s].index];t.beforeEC()}for(let i=0;i<this.cells.length;i++){t=this.cells[i];for(let s=0;s<t.TerminalsIn.value;s++)t.inputs[s]=this.cells[t.sIndexes[s].cell].outputs[t.sIndexes[s].index];t.Evaluate(this.t,this.k,this.simSettings),t.isOut&&s&&(e[t.cid]=t.inputs[0].toString())}s&&this.results.push({t:this.t,o:e});for(let s=0;s<this.cells.length;s++){t=this.cells[s];for(let s=0;s<t.TerminalsIn.value;s++)t.inputs[s]=this.cells[t.sIndexes[s].cell].outputs[t.sIndexes[s].index];t.afterEC()}}catch(s){throw console.log(s),postMessage({error:{desc:"simErr",log:s,cid:t.cid}}),this.End(),"Error in simulation"}this.t+=this.simSettings.hs,this.k++},Init:function(){let t=this;this.cells.forEach(function(s){try{s.Init()}catch(e){throw console.log(e),postMessage({error:{desc:"simErr",log:e,cid:s.cid}}),t.End(),"Error in simulation"}}),this.inPrg=!0,this.t=0,this.k=0,this.prevT=performance.now(),this.setRemainingSteps()},End:function(){this.cells.forEach(function(t){t.End()}),this.inPrg=!1,postMessage({ended:!0})},loop:function(t=null){let s=1;if(t)t=Math.min(t,this.rSteps),s=this.simSettings.h;else if(0===this.t)t=1,s=1;else if(this.simSettings.realtime){let e=1/this.simSettings.hs;t=Math.max(0,Math.min(e,this.rSteps)),s=this.simSettings.h}else t=Math.min(this.simSettings.pckSize,this.rSteps),s=1e3/t;for(let e=0;e<t;e++){for(;performance.now()-this.prevT<s;);this.prevT=performance.now(),this.simulate(),this.rSteps--}this.results.length&&(postMessage({put:this.results}),this.results=[]),this.rSteps<=0?this.End():this.isCont&&setTimeout(()=>{this.loop()})},setRemainingSteps:function(){this.rSteps=Math.ceil((this.simSettings.T-this.t)/this.simSettings.hs)+1},start:function(){this.inPrg||this.Init(),this.isCont=!0,setTimeout(this.loop())},stop:function(){this.rSteps=0},pause:function(){this.isCont=!1,postMessage({paused:!0})},steps:function(){this.inPrg||this.Init(),this.isCont=!1,postMessage({paused:!0}),setTimeout(this.loop(this.simSettings.steps))}};