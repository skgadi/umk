<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>UYAMAK platform</title>
  <link rel="manifest" href="manifest.json" />
  <script src="https://www.gstatic.com/firebasejs/5.5/firebase.js"></script>
  <script src="js/config.js"></script>
  <script src="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.js"></script>
  <link type="text/css" rel="stylesheet" href="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css" />
  <!--link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-w3schools.css"-->
  <link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-teal.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css"
    integrity="sha256-UzFD2WYH2U1dQpKDjjZK72VtPeWP50NoJjd26rnAdUI=" crossorigin="anonymous" />

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.4.0.min.js"
    integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/6.0.3/math.min.js"
    integrity="sha256-TNeqgLgUT/0XFsg+YaC13WI8OyU2S9E5/5P79536W6A=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
  <script src="/js/augmented-json-serialization-functions.js"></script>
  <link rel="stylesheet" href="/css/notyf.min.css" />
  <script src="/js/notyf.min.js"></script>
  <script src="/js/vue.min.js"></script>

  <!-- Sets the basepath for the library if not in same directory -->
  <script type="text/javascript">
    mxBasePath = "/javascript/src";
  </script>

  <!-- Loads and initializes the library -->
  <script type="text/javascript" src="/javascript/src/js/mxClient.js"></script>

  <script type="text/javascript">
    var graph;
    var undoManager;
    var tempGlobal;
    var outln;
    // Program starts here. Creates a sample graph in the
    // DOM node with the specified ID. This function is invoked
    // from the onLoad event handler of the document (see below).
    function main(container, outline) {
      // Checks if the browser is supported
      if (!mxClient.isBrowserSupported()) {
        // Displays an error message if the browser is not supported.
        mxUtils.error("Browser is not supported!", 200, false);
      } else {
        //Initializing global settings
        mxGraphHandler.prototype.guidesEnabled = true;
        mxGraphHandler.prototype.useGuidesForEvent = function (me) {
          return !mxEvent.isAltDown(me.getEvent());
        };
        mxConstants.GUIDE_COLOR = "#FF0000";
        mxConstants.GUIDE_STROKEWIDTH = 1;
        mxConstants.WORD_WRAP = "break-word";
        mxConstants.SHADOW_OFFSET_X = 5;
        mxConstants.SHADOW_OFFSET_Y = 5;
        mxConstants.EDGE_SELECTION_COLOR = "#ddd";
        mxConstants.VERTEX_SELECTION_COLOR = "#f00";
        mxConstants.VERTEX_SELECTION_STROKEWIDTH = 2;
        mxConstants.EDGE_SELECTION_STROKEWIDTH = 2;
        mxConstants.HANDLE_SIZE = 3;
        mxEdgeHandler.prototype.snapToTerminals = true;
        mxConnectionHandler.prototype.movePreviewAway = false;
        //mxClient.NO_FO = mxClient.NO_FO || mxClient.IS_SF || mxClient.IS_GC;
        graph = new mxGraph(container);
        graph.setPanning(true);
        graph.setTooltips(false);
        graph.htmlLabels = true;
        graph.setConnectable(true);
        graph.setAllowDanglingEdges(false);
        graph.centerZoom = false;
        graph.setMultigraph(false);
        graph.dropEnabled = true;
        graph.constrainChildren =
          false; // this won't let the the blocks inside the groups to not change size when groups are resized
        //graph.connectableEdges = false;
        graph.setRecursiveResize(false);
        graph.setConnectableEdges(false);
        var vStyle = graph.getStylesheet().getDefaultVertexStyle();
        var eStyle = graph.getStylesheet().getDefaultEdgeStyle();
        vStyle["shadow"] = false;
        vStyle["whiteSpace"] = "wrap";
        vStyle["arcSize"] = 0;
        vStyle["absoluteArcSize"] = 1;
        vStyle["rounded"] = 1;
        eStyle["edgeStyle"] = "orthogonalEdgeStyle";
        eStyle["strokeWidth"] = 1;
        //eStyle["fontSize"] = 15;
        eStyle["targetJettySize"] = 25;
        eStyle["shadow"] = false;
        eStyle["endArrow"] = "none";
        eStyle["fontColor"] = "#000";
        eStyle["verticalAlign"] = "top";
        eStyle["overflow"] = "width";
        eStyle["align"] = "right";
        //eStyle["startArrow"]="oval";
        //Block properties editor
        graph
          .getSelectionModel()
          .addListener(mxEvent.CHANGE, function (sender, evt) {
            selectionChanged();
          });
        //Change floding and unfolding icons
        graph.collapsedImage = new mxImage("images/plus.svg", 10, 10);
        graph.expandedImage = new mxImage("images/minus.svg", 10, 10);
        //Generate stylesheets
        generateStylesheets();
        //set valid drop targets
        var isValidDropTargetDefault = mxGraph.prototype.isValidDropTarget;
        mxGraph.prototype.isValidDropTarget = function (cell, cells, evt) {
          var defaultRetValue = isValidDropTargetDefault.apply(
            this,
            arguments
          );
          if (defaultRetValue) {
            if (cell.getStyle() && cell.getStyle().search("umk_group") >= 0)
              return true;
            /*else if (graph.getCellStyle(cell)["shape"] === "swimlane")
            return true;*/
            else
              return false;
          } else return defaultRetValue;
        };
        // Matches DnD inside the graph
        mxDragSource.prototype.getDropTarget = function (graph, x, y) {
          var cell = graph.getCellAt(x, y);

          if (!graph.isValidDropTarget(cell)) {
            cell = null;
          }
          return cell;
        };
        // Creates rubberband selection
        var rubberband = new mxRubberband(graph);
        var keyHandler = new mxKeyHandler(graph);
        var parent = graph.getDefaultParent();
        outln = new mxOutline(graph, outline);
        /*graph.autoSizeCellsOnAdd = true;
				graph.autoSizeCells = true;/**/
        //Adjust vertices when new group is formed
        var graphCreateGroupCell = graph.createGroupCell;
        graph.createGroupCell = function (cells) {
          var group = graphCreateGroupCell.apply(this, arguments);
          group.setStyle("umk_group;");
          group.setValue("Sub model");
          return group;
        };

        //resize children with parents
        graph.getModel().addListener(mxEvent.CELLS_RESIZED, resizeChildren);
        graph.getView().addListener(mxEvent.CELLS_RESIZED, resizeChildren);
        var resizeChildren = function (sender, evt) {
          console.log(sender);
          console.log(evt);
        };

        //Undo/redo activities
        undoManager = new mxUndoManager();
        var listener = function (sender, evt) {
          undoManager.undoableEditHappened(evt.getProperty("edit"));
        };
        graph.getModel().addListener(mxEvent.UNDO, listener);
        graph.getView().addListener(mxEvent.UNDO, listener);
        // Helper method to mark parts with constituent=1 in the style
        graph.isPart = function (cell) {
          //original code
          /*var state = this.view.getState(cell);
					var style = (state != null) ? state.style : this.getCellStyle(cell);*/
          //new code
          var style = graph.getCellStyle(cell);

          return style["constituent"] == "1";
        };
        // Redirects selection to parent
        graph.selectCellForEvent = function (cell) {
          if (this.isPart(cell)) {
            cell = this.model.getParent(cell);
          }

          mxGraph.prototype.selectCellForEvent.apply(this, arguments);
        };
        //Copy Paste of blocks
        graph.cloneCells = function (
          cells,
          allowInvalidEdges,
          mapping,
          keepPosition
        ) {
          customValidationError = false;
          var out = mxGraph.prototype.cloneCells.apply(this, arguments);
          customValidationError = true;
          return out;
        };
        mxClipboard.cellsToString = function (cells) {
          var codec = new mxCodec();
          var model = new mxGraphModel();
          var parent = model.getChildAt(model.getRoot(), 0);
          for (var i = 0; i < cells.length; i++) {
            cells[i].setValue(JSON.stringify2(cells[i].getValue()));
            model.add(parent, cells[i]);
          }
          return mxUtils.getXml(codec.encode(model));
        };
        var textInput = document.createElement("textarea");
        mxUtils.setOpacity(textInput, 0);
        textInput.style.width = "1px";
        textInput.style.height = "1px";
        var restoreFocus = false;
        var gs = graph.gridSize;
        var lastPaste = null;
        var dx = 0;
        var dy = 0;
        textInput.value = " ";
        mxEvent.addListener(document, "keydown", function (evt) {
          var source = mxEvent.getSource(evt);
          if (
            graph.isEnabled() &&
            !graph.isMouseDown &&
            !graph.isEditing() &&
            source.nodeName != "INPUT"
          ) {
            if (
              evt.keyCode == 224 ||
              (!mxClient.IS_MAC && evt.keyCode == 17) ||
              (mxClient.IS_MAC && evt.keyCode == 91)
            ) {
              if (!restoreFocus) {
                textInput.style.position = "absolute";
                textInput.style.left = graph.container.scrollLeft + 10 + "px";
                textInput.style.top = graph.container.scrollTop + 10 + "px";
                graph.container.appendChild(textInput);
                restoreFocus = true;
                textInput.focus();
                textInput.select();
              }
            }
          }
        });
        mxEvent.addListener(document, "keyup", function (evt) {
          if (
            restoreFocus &&
            (evt.keyCode == 224 || evt.keyCode == 17 || evt.keyCode == 91)
          ) {
            restoreFocus = false;
            if (!graph.isEditing()) {
              graph.container.focus();
            }
            textInput.parentNode.removeChild(textInput);
          }
        });
        var copyCells = function (graph, cells) {
          if (cells.length > 0) {
            var clones = graph.cloneCells(cells);
            for (var i = 0; i < clones.length; i++) {
              var state = graph.view.getState(cells[i]);
              if (state != null) {
                var geo = graph.getCellGeometry(clones[i]);
                if (geo != null && geo.relative) {
                  geo.relative = false;
                  geo.x = state.x / state.view.scale - state.view.translate.x;
                  geo.y = state.y / state.view.scale - state.view.translate.y;
                }
              }
            }
            textInput.value = mxClipboard.cellsToString(clones);
          }
          textInput.select();
          lastPaste = textInput.value;
        };
        mxEvent.addListener(
          textInput,
          "copy",
          mxUtils.bind(this, function (evt) {
            if (graph.isEnabled() && !graph.isSelectionEmpty()) {
              copyCells(
                graph,
                mxUtils.sortCells(
                  graph.model.getTopmostCells(graph.getSelectionCells())
                )
              );
              dx = 0;
              dy = 0;
            }
          })
        );
        mxEvent.addListener(
          textInput,
          "cut",
          mxUtils.bind(this, function (evt) {
            if (graph.isEnabled() && !graph.isSelectionEmpty()) {
              copyCells(graph, graph.removeCells());
              dx = -gs;
              dy = -gs;
            }
          })
        );
        var importXml = function (xml, dx, dy) {
          dx = dx != null ? dx : 0;
          dy = dy != null ? dy : 0;
          var cells = [];
          try {
            var doc = mxUtils.parseXml(xml);
            var node = doc.documentElement;
            if (node != null) {
              var model = new mxGraphModel();
              var codec = new mxCodec(node.ownerDocument);
              codec.decode(node, model);
              var childCount = model.getChildCount(model.getRoot());
              var targetChildCount = graph.model.getChildCount(
                graph.model.getRoot()
              );
              graph.model.beginUpdate();
              try {
                for (var i = 0; i < childCount; i++) {
                  var parent = model.getChildAt(model.getRoot(), i);
                  if (targetChildCount > i) {
                    var target =
                      childCount == 1 ?
                      graph.getDefaultParent() :
                      graph.model.getChildAt(graph.model.getRoot(), i);
                    if (!graph.isCellLocked(target)) {
                      var children = model.getChildren(parent);
                      cells = cells.concat(
                        graph.importCells(children, dx, dy, target)
                      );
                    }
                  } else {
                    parent = graph.importCells(
                      [parent],
                      0,
                      0,
                      graph.model.getRoot()
                    )[0];
                    var children = graph.model.getChildren(parent);
                    graph.moveCells(children, dx, dy);
                    cells = cells.concat(children);
                  }
                }

                for (var i = 0; i < cells.length; i++) {
                  try {
                    cells[i].setValue(JSON.parse2(cells[i].getValue()));
                  } catch (e) {}
                }
              } finally {
                graph.model.endUpdate();
              }
            }
          } catch (e) {
            //alert(e);
            throw e;
          }
          return cells;
        };
        var pasteText = function (text) {
          var xml = mxUtils.trim(text);
          var x =
            graph.container.scrollLeft / graph.view.scale -
            graph.view.translate.x;
          var y =
            graph.container.scrollTop / graph.view.scale -
            graph.view.translate.y;
          if (xml.length > 0) {
            if (lastPaste != xml) {
              lastPaste = xml;
              dx = 0;
              dy = 0;
            } else {
              dx += gs;
              dy += gs;
            }
            if (xml.substring(0, 14) == "<mxGraphModel>") {
              graph.setSelectionCells(importXml(xml, dx, dy));
              graph.scrollCellToVisible(graph.getSelectionCell());
            }
          }
        };
        var extractGraphModelFromEvent = function (evt) {
          var data = null;
          if (evt != null) {
            var provider =
              evt.dataTransfer != null ? evt.dataTransfer : evt.clipboardData;
            if (provider != null) {
              if (
                document.documentMode == 10 ||
                document.documentMode == 11
              ) {
                data = provider.getData("Text");
              } else {
                data =
                  mxUtils.indexOf(provider.types, "text/html") >= 0 ?
                  provider.getData("text/html") :
                  null;
                if (
                  mxUtils.indexOf(
                    provider.types,
                    "text/plain" && (data == null || data.length == 0)
                  )
                ) {
                  data = provider.getData("text/plain");
                }
              }
            }
          }
          return data;
        };
        mxEvent.addListener(textInput, "paste", function (evt) {
          textInput.value = "";
          if (graph.isEnabled()) {
            var xml = extractGraphModelFromEvent(evt);
            if (xml != null && xml.length > 0) {
              pasteText(xml);
            } else {
              window.setTimeout(
                mxUtils.bind(this, function () {
                  pasteText(textInput.value);
                }),
                0
              );
            }
          }
          textInput.select();
        });
        //Delete blocks
        keyHandler.bindKey(46, function (evt) {
          if (graph.isEnabled()) graph.removeCells();
        });
        //Arrow keys
        keyHandler.bindKey(38, function (evt) {
          moveGraph("up");
        });
        keyHandler.bindKey(40, function (evt) {
          moveGraph("down");
        });
        keyHandler.bindKey(39, function (evt) {
          moveGraph("right");
        });
        keyHandler.bindKey(37, function (evt) {
          moveGraph("left");
        });
        //undo and redo
        keyHandler.bindControlKey(90, function (evt) {
          if (graph.isEnabled()) {
            undoManager.undo();
          }
        });
        keyHandler.bindControlShiftKey(90, function (evt) {
          if (graph.isEnabled()) {
            undoManager.redo();
          }
        });
        //Toggle Blocks drawer
        keyHandler.bindControlKey(66, function (evt) {
          toggleSideBar("libraryOfBlocks");
        });
        //Toggle Editor drawer
        keyHandler.bindControlKey(69, function (evt) {
          toggleSideBar("editorForParameters");
        });
        //Toggle Printer drawer
        keyHandler.bindControlKey(80, function (evt) {
          toggleSideBar("printingTheModel");
        });
        //Toggle Zoom
        keyHandler.bindControlKey(107, function (evt) {
          graph.zoomIn();
        });
        keyHandler.bindControlKey(187, function (evt) {
          graph.zoomIn();
        });
        keyHandler.bindControlKey(109, function (evt) {
          graph.zoomOut();
        });
        keyHandler.bindControlKey(189, function (evt) {
          graph.zoomOut();
        });
        keyHandler.bindControlKey(96, function (evt) {
          graph.zoomActual();
        });
        keyHandler.bindControlKey(48, function (evt) {
          graph.zoomActual();
        });
        keyHandler.bindControlKey(97, function (evt) {
          graph.fit();
        });
        keyHandler.bindControlKey(49, function (evt) {
          graph.fit();
        });
        //Group and ungroup
        keyHandler.bindControlKey(71, function (evt) {
          if (graph.isEnabled()) {
            createSubModel();
          }
        });
        keyHandler.bindControlShiftKey(71, function (evt) {
          if (graph.isEnabled()) {
            ungroupSubModel();
          }
        });

        //Minimize and maximize
        keyHandler.bindControlKey(77, function (evt) {
          foldItems();
        });
        keyHandler.bindControlShiftKey(77, function (evt) {
          foldItems(false);
        });

        // To detect if touch events are actually supported, the following condition is recommended:
        // mxClient.IS_TOUCH || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0

        // Disables built-in text selection and context menu while not editing text
        var textEditing = mxUtils.bind(this, function (evt) {
          return graph.isEditing();
        });

        container.onselectstart = textEditing;
        container.onmousedown = textEditing;

        if (
          mxClient.IS_IE &&
          (typeof document.documentMode === "undefined" ||
            document.documentMode < 9)
        ) {
          mxEvent.addListener(container, "contextmenu", textEditing);
        } else {
          container.oncontextmenu = textEditing;
        }

        graph.popupMenuHandler.autoExpand = true;

        graph.popupMenuHandler.isSelectOnPopup = function (me) {
          return mxEvent.isMouseEvent(me.getEvent());
        };

        // Installs context menu
        graph.popupMenuHandler.factoryMethod = function (menu, cell, evt) {
          menu.addItem("Item 1", null, function () {
            alert("Item 1");
          });

          menu.addSeparator();

          var submenu1 = menu.addItem("Submenu 1", null, null);

          menu.addItem(
            "Subitem 1",
            null,
            function () {
              alert("Subitem 1");
            },
            submenu1
          );
          menu.addItem(
            "Subitem 1",
            null,
            function () {
              alert("Subitem 2");
            },
            submenu1
          );
        };

        // Context menu trigger implementation depending on current selection state
        // combined with support for normal popup trigger.
        var cellSelected = false;
        var selectionEmpty = false;
        var menuShowing = false;

        graph.fireMouseEvent = function (evtName, me, sender) {
          if (evtName == mxEvent.MOUSE_DOWN) {
            // For hit detection on edges
            me = this.updateMouseEvent(me);

            cellSelected = this.isCellSelected(me.getCell());
            selectionEmpty = this.isSelectionEmpty();
            menuShowing = graph.popupMenuHandler.isMenuShowing();
          }

          mxGraph.prototype.fireMouseEvent.apply(this, arguments);
        };

        // Shows popup menu if cell was selected or selection was empty and background was clicked
        graph.popupMenuHandler.mouseUp = function (sender, me) {
          this.popupTrigger = !graph.isEditing() &&
            (this.popupTrigger ||
              (!menuShowing &&
                !graph.isEditing() &&
                !mxEvent.isMouseEvent(me.getEvent()) &&
                ((selectionEmpty &&
                    me.getCell() == null &&
                    graph.isSelectionEmpty()) ||
                  (cellSelected && graph.isCellSelected(me.getCell())))));
          mxPopupMenuHandler.prototype.mouseUp.apply(this, arguments);
        };
        // Adds mouse wheel handling for zoom
        /*mxEvent.addMouseWheelListener(function (evt, up) {
        	if (up) {
        		graph.zoomIn();
        	} else {
        		graph.zoomOut();
        	}
        	mxEvent.consume(evt);
        });*/

        // Tap and hold on background starts rubberband for multiple selected
        // cells the cell associated with the event is deselected
        graph.addListener(mxEvent.TAP_AND_HOLD, function (sender, evt) {
          if (!mxEvent.isMultiTouchEvent(evt)) {
            var me = evt.getProperty("event");
            var cell = evt.getProperty("cell");

            if (cell == null) {
              var pt = mxUtils.convertPoint(
                this.container,
                mxEvent.getClientX(me),
                mxEvent.getClientY(me)
              );
              rubberband.start(pt.x, pt.y);
            } else if (
              graph.getSelectionCount() > 1 &&
              graph.isCellSelected(cell)
            ) {
              graph.removeSelectionCell(cell);
            }

            // Blocks further processing of the event
            evt.consume();
          }
        });

        // Adds custom hit detection if native hit detection found no cell
        graph.updateMouseEvent = function (me) {
          var me = mxGraph.prototype.updateMouseEvent.apply(this, arguments);
          if (me.getState() == null) {
            var cell = this.getCellAt(me.graphX, me.graphY);
            if (
              cell != null &&
              this.isSwimlane(cell) &&
              this.hitsSwimlaneContent(cell, me.graphX, me.graphY)
            ) {
              cell = null;
            } else {
              me.state = this.view.getState(cell);

              if (me.state != null && me.state.shape != null) {
                this.container.style.cursor =
                  me.state.shape.node.style.cursor;
              }
            }
          }

          if (me.getState() == null) {
            this.container.style.cursor = "default";
          }

          return me;
        };

        //Lines before connecting edges
        graph.view.updateFixedTerminalPoint = function (
          edge,
          terminal,
          source,
          constraint
        ) {
          mxGraphView.prototype.updateFixedTerminalPoint.apply(
            this,
            arguments
          );
          var pts = edge.absolutePoints;
          var pt = pts[source ? 0 : pts.length - 1];
          if (
            terminal != null &&
            pt == null &&
            this.getPerimeterFunction(terminal) == null
          ) {
            edge.setAbsoluteTerminalPoint(
              new mxPoint(
                this.getRoutingCenterX(terminal),
                this.getRoutingCenterY(terminal)
              ),
              source
            );
          }
        };
        graph.connectionHandler.createEdgeState = function (me) {
          var edge = graph.createEdge(null, null, null, null, null);
          return new mxCellState(
            this.graph.view,
            edge,
            this.graph.getCellStyle(edge)
          );
        };
        //Custom Grid
        (function () {
          try {
            var canvas = document.createElement("canvas");
            canvas.style.position = "absolute";
            canvas.style.top = "0px";
            canvas.style.left = "0px";
            canvas.style.zIndex = -1;
            graph.container.appendChild(canvas);
            var ctx = canvas.getContext("2d");
            var mxGraphViewIsContainerEvent =
              mxGraphView.prototype.isContainerEvent;
            mxGraphView.prototype.isContainerEvent = function (evt) {
              return (
                mxGraphViewIsContainerEvent.apply(this, arguments) ||
                mxEvent.getSource(evt) == canvas
              );
            };
            var s = 0;
            var gs = 0;
            var tr = new mxPoint();
            var w = 0;
            var h = 0;
            repaintGrid();

            function hideGrid() {
              canvas.style.display = "none";
            }

            function showGrid() {
              canvas.style.display = "block";
            }

            function repaintGrid() {
              if (ctx != null) {
                var bounds = graph.getGraphBounds();
                var width = Math.max(
                  bounds.x + bounds.width,
                  graph.container.clientWidth
                );
                var height = Math.max(
                  bounds.y + bounds.height,
                  graph.container.clientHeight
                );
                var sizeChanged = width != w || height != h;
                if (
                  graph.view.scale != s ||
                  graph.view.translate.x != tr.x ||
                  graph.view.translate.y != tr.y ||
                  gs != graph.gridSize ||
                  sizeChanged
                ) {
                  tr = graph.view.translate.clone();
                  s = graph.view.scale;
                  gs = graph.gridSize;
                  w = width;
                  h = height;
                  if (!sizeChanged) {
                    ctx.clearRect(0, 0, w, h);
                  } else {
                    canvas.setAttribute("width", w);
                    canvas.setAttribute("height", h);
                  }
                  var tx = tr.x * s;
                  var ty = tr.y * s;
                  var minStepping = graph.gridSize;
                  var stepping = minStepping * s;
                  if (stepping < minStepping) {
                    var count =
                      Math.round(Math.ceil(minStepping / stepping) / 2) * 2;
                    stepping = count * stepping;
                  }
                  var xs = Math.floor((0 - tx) / stepping) * stepping + tx;
                  var xe = Math.ceil(w / stepping) * stepping;
                  var ys = Math.floor((0 - ty) / stepping) * stepping + ty;
                  var ye = Math.ceil(h / stepping) * stepping;
                  xe += Math.ceil(stepping);
                  ye += Math.ceil(stepping);
                  var ixs = Math.round(xs);
                  var ixe = Math.round(xe);
                  var iys = Math.round(ys);
                  var iye = Math.round(ye);
                  ctx.strokeStyle = "#c0c0c0";
                  ctx.fillStyle = "#fff";//"#f1f1f1";
                  ctx.fillRect(0, 0, canvas.width, canvas.height);
                  ctx.beginPath();
                  ctx.lineWidth = 0.5;
                  for (var x = xs; x <= xe; x += stepping) {
                    x = Math.round((x - tx) / stepping) * stepping + tx;
                    var ix = Math.round(x);
                    ctx.moveTo(ix + 0.5, iys + 0.5);
                    ctx.lineTo(ix + 0.5, iye + 0.5);
                  }
                  for (var y = ys; y <= ye; y += stepping) {
                    y = Math.round((y - ty) / stepping) * stepping + ty;
                    var iy = Math.round(y);
                    ctx.moveTo(ixs + 0.5, iy + 0.5);
                    ctx.lineTo(ixe + 0.5, iy + 0.5);
                  }
                  ctx.closePath();
                  ctx.stroke();
                  ctx.strokeStyle = "#808080";
                  stepping = stepping * 5;
                  xs = Math.floor((0 - tx) / stepping) * stepping + tx;
                  xe = Math.ceil(w / stepping) * stepping;
                  ys = Math.floor((0 - ty) / stepping) * stepping + ty;
                  ye = Math.ceil(h / stepping) * stepping;
                  xe += Math.ceil(stepping);
                  ye += Math.ceil(stepping);
                  ixs = Math.round(xs);
                  ixe = Math.round(xe);
                  iys = Math.round(ys);
                  iye = Math.round(ye);
                  ctx.beginPath();
                  ctx.lineWidth = 0.5;
                  for (var x = xs; x <= xe; x += stepping) {
                    x = Math.round((x - tx) / stepping) * stepping + tx;
                    var ix = Math.round(x);
                    ctx.moveTo(ix + 0.5, iys + 0.5);
                    ctx.lineTo(ix + 0.5, iye + 0.5);
                  }
                  for (var y = ys; y <= ye; y += stepping) {
                    y = Math.round((y - ty) / stepping) * stepping + ty;
                    var iy = Math.round(y);
                    ctx.moveTo(ixs + 0.5, iy + 0.5);
                    ctx.lineTo(ixe + 0.5, iy + 0.5);
                  }
                  ctx.closePath();
                  ctx.stroke();
                  ctx.strokeStyle = "#404040";
                  stepping = stepping * 2;
                  xs = Math.floor((0 - tx) / stepping) * stepping + tx;
                  xe = Math.ceil(w / stepping) * stepping;
                  ys = Math.floor((0 - ty) / stepping) * stepping + ty;
                  ye = Math.ceil(h / stepping) * stepping;
                  xe += Math.ceil(stepping);
                  ye += Math.ceil(stepping);
                  ixs = Math.round(xs);
                  ixe = Math.round(xe);
                  iys = Math.round(ys);
                  iye = Math.round(ye);
                  ctx.beginPath();
                  ctx.lineWidth = 0.5;
                  for (var x = xs; x <= xe; x += stepping) {
                    x = Math.round((x - tx) / stepping) * stepping + tx;
                    var ix = Math.round(x);
                    ctx.moveTo(ix + 0.5, iys + 0.5);
                    ctx.lineTo(ix + 0.5, iye + 0.5);
                  }
                  for (var y = ys; y <= ye; y += stepping) {
                    y = Math.round((y - ty) / stepping) * stepping + ty;
                    var iy = Math.round(y);
                    ctx.moveTo(ixs + 0.5, iy + 0.5);
                    ctx.lineTo(ixe + 0.5, iy + 0.5);
                  }
                  ctx.closePath();
                  ctx.stroke();
                }
              }
            }
          } catch (e) {
            /* mxLog.show();
             mxLog.debug("Using background image");*/
            container.style.backgroundImage = "url('/images/grid.gif')";
          }
          outln.mouseDown = function (sender, me) {
            hideGrid();
            return mxOutline.prototype.mouseDown.apply(this, arguments);
          };
          outln.mouseUp = function (sender, me) {
            showGrid();
            return mxOutline.prototype.mouseUp.apply(this, arguments);
          };
          /*outln.mouseMove = function(sender, me) {
            repaintGrid();
            console.log("sdf");
            ctx.restore
            return mxOutline.prototype.mouseMove.apply(this, arguments);
          }*/

          graph.umkGridsRefresh = function () {
            repaintGrid();
          };

          var mxGraphViewValidateBackground =
            mxGraphView.prototype.validateBackground;
          mxGraphView.prototype.validateBackground = function () {
            try {
              repaintGrid();
            } catch (e) {}
            MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
            return mxGraphViewValidateBackground.apply(this, arguments);
          };
        })();
        //Connection switching source traget, when required
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (
          sender,
          evt
        ) {
          var edge = evt.getProperty("cell");
          var source = graph.getModel().getTerminal(edge, true);
          var target = graph.getModel().getTerminal(edge, false);
          if (
            source.style.search("umk_input") >= 0 &&
            target.style.search("umk_output") >= 0
          ) {
            graph.getModel().setTerminal(edge, source, false);
            graph.getModel().setTerminal(edge, target, true);
          }
        });
        //Connection validation
        var customValidationError = true;
        var default_getEdgeValidationError =
          mxGraph.prototype.getEdgeValidationError;
        mxGraph.prototype.getEdgeValidationError = function (
          edge,
          source,
          target
        ) {
          //console.log(source.edges);
          var defaultOut = default_getEdgeValidationError.apply(
            this,
            arguments
          );
          if (customValidationError) {
            var outError;
            try {
              if (source.parent === target.parent)
                outError = "Cannot connect to the same block.";
              if (
                source.style.search("umk_input") >= 0 &&
                target.style.search("umk_input") >= 0
              )
                outError = "Cannot connect both the inputs.";
              if (
                source.style.search("umk_output") >= 0 &&
                target.style.search("umk_output") >= 0
              )
                outError = "Cannot connect both the outputs.";
              if (
                (target.style.search("umk_input") >= 0 &&
                  target.getEdgeCount() > 0) ||
                (source.style.search("umk_input") >= 0 &&
                  source.getEdgeCount() > 0)
              )
                outError = "Only one input is allowed per port.";
            } catch (e) {} finally {
              return outError || defaultOut;
            }
          } else return defaultOut;
        };
        mxGraph.prototype.validationAlert = function (message) {
          notyf.error(message);
        };

        //Dynamic Edge coloring
        var defaultModelStyle = graph.model.getStyle;
        graph.model.getStyle = function (cell) {
          var style = defaultModelStyle.apply(this, arguments);
          if (cell != null) {
            if (this.isEdge(cell)) {
              var target = this.getTerminal(cell, true);
              if (target != null) {
                var state = graph.getView().getState(target);
                var targetStyle =
                  state != null ? state.style : graph.getCellStyle(target);
                var fill = mxUtils.getValue(
                  targetStyle,
                  mxConstants.STYLE_FILLCOLOR
                );
                if (fill != null) {
                  style += ";strokeColor=" + fill;
                }
              }
            }
          }
          return style;
        };

        //selection of a vertix
        mxGraph.prototype.isCellSelectable = function (cell) {
          var state = this.view.getState(cell);
          var style = state != null ? state.style : this.getCellStyle(cell);

          return (
            this.isCellsSelectable() &&
            !this.isCellLocked(cell) &&
            style["selectable"] != 0
          );
        };

        //How Label is handled for a model
        graph.getLabel = function (cell) {
          //console.log(cell);
          if (!!cell.value) {
            if (cell.style.search("umk_display") >= 0) {
              return cell.value.show || "$[\\cdot]$";
            }
            if (cell.style.search("umk_model") >= 0) {
              try {
                eval(
                  "var tempModel = new umk_" +
                  cell.value.bid +
                  " (cell.value);"
                );
                setCaption(cell, tempModel.Name);
                return (
                  "<p style='margin:0; padding: 0;'>" +
                  tempModel.Icon().html +
                  "</p>"
                );
              } catch (e) {
                pullDBAndGenModel(cell.value.bid)
                  .then(function () {
                    eval(
                      "var tempModel = new umk_" +
                      cell.value.bid +
                      " (cell.value);"
                    );
                    graph.cellLabelChanged(cell, tempModel.Name);
                  })
                  .catch(function (e) {
                    console.log(e);
                    notyf.error("Error in loading the block");
                  });
                return "Loading...";
              }
            } else return cell.value; //"$\\text{"+cell.value+"}$";
          } else return null;
        };
        graph.getEditingValue = function (cell, evt) {
          if (!!cell.value) {
            if (typeof cell.value === "object") return cell.value.Name || "";
            else return cell.value;
          } else return null;
        };
        graph.labelChanged = function (cell, newValue, trigger) {
          if (!!cell.value) {
            if (typeof cell.value === "object") {
              var value = mxUtils.clone(cell.value);
              value.Name = newValue;
              newValue = value;
            }
          }
          mxGraph.prototype.labelChanged.apply(this, arguments);
        };

        // Adds cells to the model in a single step
        graph.getModel().beginUpdate();
        try {
          /*var v1 = graph.insertVertex(parent, null, 'H<b>e</b>llo,', 20, 20, 80, 30);
					var v2 = graph.insertVertex(parent, null, 'World!', 200, 150, 80, 30);
					var e1 = graph.insertEdge(parent, null, '', v1, v2);
					var v1 = graph.insertVertex(parent, null, 'A', 20, 20, 100, 40);
					var v1 = graph.insertVertex(parent, null, 'A', 20, 20, 100, 40);*/
        } finally {
          // Updates the display
          graph.getModel().endUpdate();
        }
      }
    }

    function insertVertex(v1, umkModel, x, y, evt, cell) {
      var parent = graph.getDefaultParent();
      var model = graph.getModel();
      model.beginUpdate();
      try {
        var IconDetails = umkModel.Icon();
        var inLabels = IconDetails.inLabels || [];
        var outLabels = IconDetails.outLabels || [];
        var newPt = {
          x: x,
          y: y
        };
        if (cell) {
          var pt = cell.getGeometry().getPoint();
          newPt.x -= pt.x;
          newPt.y -= pt.y;
        }
        //additional style
        var addStyle = "";
        if (
          umkModel.Category === "sinks" &&
          IconDetails.output === "display"
        ) {
          addStyle += "umk_display;";
        }
        v1 = graph.insertVertex(
          cell,
          null,
          umkModel,
          newPt.x,
          newPt.y,
          LIBRARY_SUMMARY[umkModel.Category]["blocks"][umkModel.bid].size
          .width,
          LIBRARY_SUMMARY[umkModel.Category]["blocks"][umkModel.bid].size
          .height,
          "umk_model;" +
          addStyle +
          "fillColor=" +
          LIBRARY_SUMMARY[umkModel.Category].colors.bg +
          ";strokeColor=" +
          LIBRARY_SUMMARY[umkModel.Category].colors.bg +
          ";"
        );
        //shape=swimlane;startSize=20;foldable=0;swimlaneFillColor="+umkModel.Colors.bg+";

        v1.setConnectable(false);
        v1.geometry.alternateBounds = new mxRectangle(0, 0, 200, 20);
        setTermianls(v1, "umk_input");
        setTermianls(v1, "umk_output");
        /*if ((umkModel.Category === "sinks") && (IconDetails.output === 'display')) {
          var disp = graph.insertVertex(
            v1, null, "$[.]$", 0, 0, 0, 0, "umk_display", true
          );
          disp.setConnectable(false);
        }*/
        var EO = graph.insertVertex(
          v1,
          null,
          "",
          0.5,
          0,
          0,
          0,
          "umk_EO",
          true
        );
        EO.setConnectable(false);
        var Details = graph.insertVertex(
          v1,
          null,
          umkModel.Name,
          0.5,
          1,
          0,
          0,
          "umk_caption",
          true
        );
        Details.geometry.offset = new mxPoint(0, 0);
        Details.setConnectable(false);
        graph.setSelectionCell(v1);
      } finally {
        model.endUpdate();
      }
    }

    function addANewDraggableIcon(sidebar, data) {
      var addVertices = function (graph, evt, cell, x, y) {
        try {
          eval("var umkModel = new umk_" + data.key + "();");
          //console.log(data);
          umkModel.Constructor({});
          insertVertex(v1, umkModel, x, y, evt, cell);
        } catch (e) {
          console.log(e);
          graph.removeCells([v1]);
          notyf.error(
            "Error in the mathematical model. Your internet connection must be failing. If your internet connection is good, please contact the support."
          );
        }
        graph.setSelectionCell(v1);
      };
      var finishDragAct = function (graph, evt, cell, x, y) {
        pullDBAndGenModel(data.key)
          .then(function () {
            addVertices(graph, evt, cell, x, y);
          })
          .catch(function () {
            notyf.error(
              "Unknown error: please contact support if it continues."
            );
          });
      };
      var v1;
      var img = document.createElement("img");
      /*blockDiv.innerHTML = "Name:"+data.name+"; Description:"+data.description;
			blockDiv.setAttribute('id', 'block_'+data.order+'for_'+data.key);*/
      var img = document.createElement("img");
      img.setAttribute(
        "src",
        svgTextToURL(getIconWith(data.colors, data.icon))
      );
      img.style.width = "50px";
      img.style.height = "50px";
      img.title =
        data.name +
        ": " +
        data.description +
        "\n\nDrag this to the diagram to create a new vertex";
      sidebar.appendChild(img);

      var dragElt = document.createElement("div");
      dragElt.style.border = "dashed black 1px";
      dragElt.style.width = data.size.width + "px";
      dragElt.style.height = data.size.height + "px";
      var ds = mxUtils.makeDraggable(
        img,
        graph,
        finishDragAct,
        dragElt,
        0,
        0,
        true,
        true
      );
      ds.setGuidesEnabled(true);
    }

    function generateStylesheets() {
      var style = new Object();
      style.foldable = 0;
      style.overflow = "hidden";
      style.verticalAlign = "middle";
      style.fontColor = "#fff";
      //foldable=0;overflow=hidden;verticalAlign=middle;fontColor=#fff;
      graph.getStylesheet().putCellStyle("umk_model", style);
      var style = new Object();
      style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_SWIMLANE;
      style.startSize = 25;
      style.strokeWidth = 2;
      style.arcSize = 0;
      graph.getStylesheet().putCellStyle("umk_group", style);
      style = new Object();
      style.constituent = 1;
      style.verticalLabelPosition = "bottom";
      style.verticalAlign = "top";
      style.fontColor = "#000";
      //constituent=1;verticalLabelPosition=bottom;verticalAlign=top;
      graph.getStylesheet().putCellStyle("umk_caption", style);
      style = new Object();
      style.constituent = 1;
      style.align = "center";
      style.verticalAlign = "bottom";
      style.fontColor = "#000";
      //constituent=1;align=center;verticalAlign=bottom;fontColor=#000000;
      graph.getStylesheet().putCellStyle("umk_EO", style);
      style = new Object();
      style.constituent = 1;
      style.verticalAlign = "middle";
      style.fontColor = "#fff";
      style.labelPosition = "right";
      style.labelWidth = 15;
      style.align = "left";
      style.shape = "triangle";
      style.portConstraint = "west";
      style.overflow = "fit";
      //constituent=1;verticalAlign=middle;fontColor=#ffffff;labelPosition=right;labelWidth=80;align=left;shape=triangle;portConstraint=west;
      graph.getStylesheet().putCellStyle("umk_input", style);
      style = new Object();
      style.constituent = 1;
      style.verticalAlign = "middle";
      style.fontColor = "#fff";
      style.labelPosition = "left";
      style.labelWidth = 15;
      style.align = "right";
      style.shape = "triangle";
      style.portConstraint = "east";
      style.overflow = "fit";
      //constituent=1;fontColor=#ffffff;labelPosition=left;labelWidth=80;align=right;shape=triangle;portConstraint=east;
      graph.getStylesheet().putCellStyle("umk_output", style);

      /*style = new Object();
      style.constituent = 1;
      style.align = "center";
      style.verticalAlign = "top";
      style.fontColor = "#fff";
      style.overflow = "width";
      graph.getStylesheet().putCellStyle("umk_display", style);*/
    }
    //Group blocks
    function createSubModel() {
      var model = graph.getModel();
      model.beginUpdate();
      try {
        var subModel = graph.groupCells(null, 50, graph.getSelectionCells());
        subModel.geometry.alternateBounds = new mxRectangle(0, 0, 200, 25);
        graph.setSelectionCell(subModel);
      } catch (e) {
        console.log(e);
        notyf.error("Unable to group the selected items");
      } finally {
        model.endUpdate();
      }
    }

    function ungroupSubModel() {
      var model = graph.getModel();
      model.beginUpdate();
      try {
        var cells = graph.getSelectionCells();
        for (var i = 0; i < cells.length; i++) {
          if (cells[i].getStyle().search("umk_group") >= 0) {
            var sCells = graph.getSelectionCells();
            sCells = sCells.concat(cells[i].children);
            //console.log(sCells);
            graph.ungroupCells([cells[i]]);
            graph.setSelectionCells(sCells);
          }
        }
      } catch (e) {
        console.log(e);
        notyf.error("Unable to un-group the selected items");
      } finally {
        model.endUpdate();
      }
    }
    // fold and unfold
    function foldItems(fold = true) {
      if (graph.getSelectionCells().length > 0) {
        graph.foldCells(fold, false, graph.getSelectionCells());
      } else graph.foldCells(fold, false, graph.getDefaultParent().children);
    }
    //Change caption
    function setCaption(Cell, value) {
      var children = Cell.children;
      for (var i = 0; i < children.length; i++) {
        if (children[i].style.search("umk_caption") >= 0) {
          children[i].setValue(value);
          graph.refresh(children[i]);
        }
      }
    }
    //Prepare input and output terminals
    function setTermianls(Cell, type = "umk_input") {
      if (!!Cell && typeof Cell === "object") {
        var IconDetails = Cell.value.Icon();
        var Labels;
        var RequiredCount;
        var position;
        if (type === "umk_input") {
          Labels = IconDetails.inLabels || [];
          RequiredCount = Cell.value.TerminalsIn.value;
          position = {
            x: 0,
            size: {
              width: 4,
              height: 8
            },
            offset: {
              x: -4,
              y: -4
            }
          };
        } else {
          Labels = IconDetails.outLabels || [];
          RequiredCount = Cell.value.TerminalsOut.value;
          position = {
            x: 1,
            size: {
              width: 4,
              height: 8
            },
            offset: {
              x: 0,
              y: -4
            }
          };
        }
        //Adjust input terminals
        //Check count of available input terminals
        var availableCount = 0;
        var cellsToRemove = [];
        for (
          var i = 0; i < (!!Cell.children ? Cell.children.length : 0); i++
        ) {
          if (Cell.children[i].style.search(type) >= 0) {
            if (availableCount < RequiredCount) {
              Cell.children[i].geometry.y =
                (availableCount + 1) / (RequiredCount + 1);
              Cell.children[i].setValue(Labels[availableCount] || "");
            } else {
              cellsToRemove.push(Cell.children[i]);
            }
            availableCount++;
          }
        }
        graph.removeCells(cellsToRemove);
        //Add more cells if required
        for (var i = 0; i < RequiredCount - availableCount; i++) {
          var port = graph.insertVertex(
            Cell,
            null,
            Labels[i + availableCount] || "",
            position.x,
            (availableCount + i + 1) / (RequiredCount + 1),
            position.size.width,
            position.size.height,
            type +
            ";fillColor=" +
            LIBRARY_SUMMARY[Cell.value.Category].colors.bg +
            ";strokeColor=" +
            LIBRARY_SUMMARY[Cell.value.Category].colors.bg +
            ";",
            true
          );
          port.geometry.offset = new mxPoint(
            position.offset.x,
            position.offset.y
          );
        }
      }
    }

    //Move the graph
    function moveGraph(direction = "up", step = 10) {
      //step = step*graph.view.scale;
      var value = graph.view.getTranslate();
      switch (direction) {
        case "up":
          value.y += step;
          break;
        case "down":
          value.y -= step;
          break;
        case "left":
          value.x += step;
          break;
        case "right":
          value.x -= step;
          break;
      }
      graph.view.setTranslate(value.x, value.y);
      graph.view.refresh();
    }
  </script>

  <style>
    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    /*#modelContainer {
      position: fixed;
      overflow: hidden;
      top: 40px;
      left: 0px;
      bottom: 18px;
      right: 0px;
      cursor: default;
    }*/

    /*.MJXc-display {
      margin: 0 !important;
    }*/

    .block-margin {
      margin: 0.5em 0 5em 0 !important;
    }

    .rotateNote {
      -webkit-transform: rotate(90deg);
      -moz-transform: rotate(90deg);
      -o-transform: rotate(90deg);
      -ms-transform: rotate(90deg);
      transform: rotate(90deg);
    }

    .tool-item {
      padding: 0px 8px !important;
    }

    .single-tool-item {
      height: 23.92px;
    }

    .zeroPadding {
      padding: 0 !important;
    }

    #flex {
      display: flex;
      flex-direction: row;
    }

    .gutter {
      background-color: #aaa;

      background-repeat: no-repeat;
      background-position: 50%;
    }

    .gutter.gutter-vertical {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAFAQMAAABo7865AAAABlBMVEVHcEzMzMzyAv2sAAAAAXRSTlMAQObYZgAAABBJREFUeF5jOAMEEAIEEFwAn3kMwcB6I2AAAAAASUVORK5CYII=");
      cursor: row-resize;
    }

    .gutter.gutter-horizontal {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==");
      cursor: col-resize;
    }
  </style>
  <script src="https://unpkg.com/split.js/dist/split.min.js"></script>
</head>

<body>
  <div id="mainToobar" class="w3-bar w3-blue-gray" style="padding: 0px 0px">
    <div class="w3-bar-item w3-button tool-item single-tool-item">
      <i class="fa-fw fas fa-home"></i>
    </div>
    <template v-for="(topTool, index) in toolBar">
      <div class="w3-dropdown-hover">
        <div class="w3-button tool-item">{{ topTool.value }}</div>
        <div class="w3-dropdown-content w3-bar-block w3-card-4" style="width: 400px;">
          <template v-for="(tool, index) in topTool.items">
            <hr v-if="tool.value === 'hl'" style="margin:0; border-color: #ddd;" />
            <div v-else class="w3-bar-item w3-button" v-bind:title="tool.text" style="padding: 8px 4px;">
              <span><i v-if="!!tool.icon" class="fa-fw" v-bind:class="tool.icon"></i></span>
              <span style="margin-left: 1em;">{{ tool.value }}</span>
              <span v-if="!!tool.shortcut" class="w3-right w3-small w3-gray w3-round"
                style="padding: 4px;">{{ tool.shortcut }}</span>
            </div>
          </template>
        </div>
      </div>
    </template>
    <div id="simulationToolForBar">
      <div class="w3-bar-item w3-button tool-item single-tool-item w3-right">
        <i class="fas fa-play"></i> / <i class="fas fa-stop"></i>
      </div>
    </div>
  </div>
  <div id="flex" style="height:calc(100% - 38.92px)">
    <div id="flex-1" style="overflow:auto;">
      <div class="w3-block w3-khaki w3-hover-yellow w3-button" style="padding: 0 8px;"
        onclick="mainSplit.setSizes([0,100])">
        <div class="w3-right">
          <i class="fas fa-sign-out-alt fa-rotate-180"></i>
        </div>
        <div class="w3-left">
          Close
        </div>
      </div>
      <div class="w3-row w3-gray">
        <div class="w3-col s2 w3-button tablink w3-large zeroPadding w3-border w3-border-black"
          onclick="selectTabItem(event,'folder')">
          <i class="far fa-folder"></i>
        </div>
        <div class="w3-col s2 w3-button tablink w3-large zeroPadding w3-border w3-border-black w3-blue"
          onclick="selectTabItem(event,'library')" style="padding: 0;">
          <i class="fas fa-drafting-compass"></i>
        </div>
        <div class="w3-col s2 w3-button tablink w3-large zeroPadding w3-border w3-border-black"
          onclick="selectTabItem(event,'editorForParameters')">
          <i class="far fa-edit"></i>
        </div>
        <div class="w3-col s2 w3-button tablink w3-large zeroPadding w3-border w3-border-black"
          onclick="selectTabItem(event,'simulation')">
          <i class="fas fa-play"></i>
        </div>
        <div class="w3-col s2 w3-button tablink w3-large zeroPadding w3-border w3-border-black"
          onclick="selectTabItem(event,'settings')">
          <i class="fas fa-cogs"></i>
        </div>
        <div class="w3-col s2 w3-button tablink w3-large zeroPadding w3-border w3-border-black"
          onclick="selectTabItem(event,'printingTheModel')">
          <i class="fas fa-print"></i>
        </div>
      </div>
      <div class="tabContent" style="display: block;" id="library">
        <div id="blocksBar"></div>
      </div>
      <div class="tabContent" style="display: none;" id="editorForParameters">
        <div v-if="!!cellModel.model">
          <div>
            <p class="w3-large" style="margin:0px;"><b>Connection name</b></p>
            <input class="w3-input w3-border w3-border-theme" v-model.trim="cellModel.value" type="text"
              placeholder="Enter a name" />
            <div class="w3-container w3-pale-yellow" v-html="cellModel.value"></div>
          </div>
          <div class="w3-block w3-theme w3-hover-green w3-button" @click="applyCellValue">
            <div class="w3-right">
              <i class="fas fa-check"></i>
            </div>
            <div class="w3-left">
              Appy
            </div>
          </div>
        </div>
        <div v-else-if="!!uyamakModel">
          <div>
            <p class="w3-large" style="margin:0px;"><b>Block name</b></p>
            <input class="w3-input w3-border w3-border-theme" v-model.trim="uyamakModel.Name" type="text" />
            <div class="w3-container w3-pale-yellow" v-html="uyamakModel.Name"></div>
          </div>
          <div v-if="uyamakModel.TerminalsIn.editable">
            <p class="w3-large" style="margin:0px;">
              <b>Input terminals count</b>
            </p>
            <input class="w3-input w3-border w3-border-theme" v-model.number="uyamakModel.TerminalsIn.value"
              type="number" v-bind:min="uyamakModel.TerminalsIn.min" v-bind:max="uyamakModel.TerminalsIn.max" />
          </div>
          <div v-if="uyamakModel.TerminalsOut.editable">
            <p class="w3-large" style="margin:0px;">
              <b>Output terminals count</b>
            </p>
            <input class="w3-input w3-border w3-border-theme" v-model.number="uyamakModel.TerminalsOut.value"
              type="number" v-bind:min="uyamakModel.TerminalsOut.min" v-bind:max="uyamakModel.TerminalsOut.max" />
          </div>
          <div v-if="uyamakModel.Parameters.length>0">
            <p class="w3-large" style="margin:0px;"><b>Parameters</b></p>
            <template v-for="(Parameter, index) in uyamakModel.Parameters">
              <div class="w3-theme-d3 w3-border w3-border-theme w3-padding w3-ripple" @click="toggleParamDisplay(index)"
                style="cursor: pointer;">
                <span v-if="!!parametersDisplay[index]" :key="index+'_'+updatingCounter"><i
                    class="fas fa-caret-down fa-fw"></i></span>
                <span v-else :key="index+'_'+updatingCounter"><i class="fas fa-caret-right fa-fw"></i></span>
                <span>{{ Parameter.Name }}</span>
              </div>
              <div v-if="!!parametersDisplay[index]">
                <div v-if="(Parameter.Dimension === 'Vector') || (Parameter.Dimension === 'Matrix')"
                  class="w3-center w3-border-bottom w3-border-theme w3-theme-d1">
                  <div @click="valueDimensionsModify(0, index)" style="width: 40px; height: 40px; padding:0px;" v-if=""
                    class="w3-circle w3-button w3-theme-l3 w3-hover-theme w3-ripple w3-border w3-border-theme w3-display-container rotateNote">
                    <div class="w3-display-middle">
                      <i class="fas fa-ellipsis-h"></i><i class="fas fa-plus-circle"></i>
                    </div>
                  </div>
                  <div @click="valueDimensionsModify(1, index)" style="width: 40px; height: 40px; padding:0px;" v-if=""
                    class="w3-circle w3-button w3-theme-l3 w3-hover-theme w3-ripple w3-border w3-border-theme w3-display-container rotateNote">
                    <div class="w3-display-middle">
                      <i class="fas fa-ellipsis-h"></i><i class="fas fa-minus-circle fa-rotate-90"></i>
                    </div>
                  </div>
                  <div v-if="(Parameter.Dimension === 'Matrix')" @click="valueDimensionsModify(2, index)"
                    style="width: 40px; height: 40px; padding:0px;" v-if=""
                    class="w3-circle w3-button w3-theme-l3 w3-hover-theme w3-ripple w3-border w3-border-theme w3-display-container">
                    <div class="w3-display-middle">
                      <i class="fas fa-ellipsis-h"></i><i class="fas fa-plus-circle"></i>
                    </div>
                  </div>
                  <div v-if="(Parameter.Dimension === 'Matrix')" @click="valueDimensionsModify(3, index)"
                    style="width: 40px; height: 40px; padding:0px;" v-if=""
                    class="w3-circle w3-button w3-theme-l3 w3-hover-theme w3-ripple w3-border w3-border-theme w3-display-container">
                    <div class="w3-display-middle">
                      <i class="fas fa-ellipsis-h"></i><i class="fas fa-minus-circle"></i>
                    </div>
                  </div>
                </div>
                <div class="w3-responsive">
                  <table class="w3-table-all">
                    <template v-for="(rowValue, index1) in uyamakModel.Parameters[index]['Value']">
                      <tr v-if="(index1 === 0) && (Parameter.Dimension === 'Matrix')" style="padding: 0;">
                        <td class="w3-light-gray w3-border w3-border-theme"></td>
                        <template v-for="(value, index2) in uyamakModel.Parameters[index]['Value'][index1]">
                          <td style="padding:0;" class="w3-light-gray w3-center w3-border w3-border-theme">
                            {{ index2 + 1 }}
                          </td>
                        </template>
                      </tr>
                      <tr style="padding: 0;" class="w3-border-theme">
                        <td v-if="(Parameter.Dimension === 'Vector') || (Parameter.Dimension === 'Matrix')"
                          style="padding:0; vertical-align: middle;" class="w3-light-gray w3-border w3-border-theme">
                          {{ index1 + 1 }}
                        </td>
                        <template v-for="(value, index2) in uyamakModel.Parameters[index]['Value'][index1]">
                          <td style="padding: 0;" class="w3-border w3-border-theme">
                            <input v-if="(['Integer', 'Real', 'Complex', 'Text'].indexOf(Parameter.Type))>=0"
                              v-bind:class="(!validateParamCellEntry(index, index1, index2))? 'w3-red':''"
                              v-model.trim="uyamakModel.Parameters[index]['Value'][index1][index2]"
                              class="w3-input w3-border-0" style="padding: 0; min-width: 75px; padding: 8px 0px;"
                              v-bind:style="(Parameter.Type !== 'Text')?'text-align: right':''" type="text" />
                            <input v-if="Parameter.Type === 'Color'"
                              v-bind:class="(!validateParamCellEntry(index, index1, index2))? 'w3-red':''"
                              v-model.trim="uyamakModel.Parameters[index]['Value'][index1][index2]"
                              class="w3-input w3-border-0"
                              style="padding: 0; min-width: 75px; padding: 0px; min-height: 35px;"
                              v-bind:style="(Parameter.Type !== 'Text')?'text-align: right':''" type="color" />
                          </td>
                        </template>
                      </tr>
                    </template>
                  </table>
                </div>
              </div>
            </template>
          </div>
          <div>
            <template v-if="invalidInputs.length>0">
              <p class="w3-large" style="margin:0px;">
                <b>Input error(s)</b>
              </p>
              <div v-html="inputErrors" class="w3-text-red"></div>
            </template>
            <template v-else-if="parametersValidationComments !== 'OK'">
              <p class="w3-large" style="margin:0px;">
                <b>Incompatable parameters</b>
              </p>
              <div v-html="parametersValidationComments"></div>
            </template>
            <template v-else>
              <p class="w3-large" style="margin:0px;"><b>Functionality</b></p>
              <div v-html="getBlockDetails()"></div>
              <div class="w3-button w3-ripple w3-lime w3-hover-green w3-bar w3-large" @click="saveModel()">
                <div class="w3-left">Apply</div>
                <div class="w3-right"><i class="far fa-save"></i></div>
              </div>
              <div class="w3-button w3-ripple w3-amber w3-hover-red w3-bar w3-large"
                onclick="changeEditModelWithSelectedBlock()">
                <div class="w3-left">Reset changes</div>
                <div class="w3-right"><i class="fas fa-undo-alt"></i></div>
              </div>
            </template>
            <div class="w3-row">
              <div class="w3-col s12 m6 l3">
                <div class="w3-button w3-theme-d1 w3-hover-theme w3-ripple w3-bar w3-xlarge" @click="rotate(0)">
                  <i class="far fa-smile"></i>
                </div>
              </div>
              <div class="w3-col s12 m6 l3">
                <div class="w3-button w3-theme-d1 w3-hover-theme w3-ripple w3-bar w3-xlarge" @click="rotate(90)">
                  <i class="far fa-smile fa-rotate-90"></i>
                </div>
              </div>
              <div class="w3-col s12 m6 l3">
                <div class="w3-button w3-theme-d1 w3-hover-theme w3-ripple w3-bar w3-xlarge" @click="rotate(180)">
                  <i class="far fa-smile fa-rotate-180"></i>
                </div>
              </div>
              <div class="w3-col s12 m6 l3">
                <div class="w3-button w3-theme-d1 w3-hover-theme w3-ripple w3-bar w3-xlarge" @click="rotate(270)">
                  <i class="far fa-smile fa-rotate-270"></i>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div v-else>Select a block to edit its parameters.</div>
      </div>
      <div class="tabContent" style="display: none;" id="printingTheModel">
        <select class="w3-select w3-border w3-border-theme" name="option" v-model="pageSize.value">
          <option v-for="(value, index) in pageSize.options" v-bind:value="index">{{ value }}</option>
        </select>
        <select class="w3-select w3-border w3-border-theme" name="option" v-model="orientation.value">
          <option v-for="(value, index) in orientation.options" v-bind:value="index">{{ value }}</option>
        </select>
        <label>Page title</label>
        <input class="w3-input w3-border w3-border-theme" v-model="title" type="text" />
        <input id="forcePages" class="w3-check" type="checkbox" checked="checked" v-model="fit.force" />
        <label for="forcePages">Scale the graph to fit in
          <input class="w3-input w3-border-theme w3-border-0" type="number" min="1" step="1"
            v-model.number="fit.numberOfPages" style="display:inline-flex; width:50px;" />
          page(s).</label>
        <div class="w3-block w3-theme w3-hover-red w3-button w3-large" @click="prepareMPDoc()">
          <div class="w3-right">
            <i class="fas fa-file-import"></i>
          </div>
          <div class="w3-left">
            Prepare document
          </div>
        </div>
      </div>
      <div class="tabContent" style="display: none;" id="settings"></div>
      <div class="tabContent" style="display: none;" id="simulation">
        <div v-if="available">
          <div class="w3-button w3-ripple w3-bar w3-teal w3-hover-light-green" @click="showExecutionOrder">
            <div class="w3-right">
              <i class="fas fa-sort-numeric-up-alt"></i>
            </div>
            <div class="w3-left">
              Show execution order
            </div>
          </div>
          <label>Sampling time ($T_S$)</label>
          <input class="w3-input w3-border w3-border-blue" v-model="sParams.Ts" v-on:blur="validateParams">
          <label>Simulation duration ($T$)</label>
          <input class="w3-input w3-border w3-border-blue" v-model="sParams.T_E" v-on:blur="validateParams">
          <div class="w3-button w3-ripple w3-bar w3-green w3-hover-light-green" @click="run">
            <div class="w3-right">
              <i class="fas fa-play"></i>
            </div>
            <div class="w3-left">
              Run
            </div>
          </div>
          <div class="w3-button w3-ripple w3-bar w3-teal w3-hover-light-green" @click="pause">
            <div class="w3-right">
              <i class="fas fa-pause"></i>
            </div>
            <div class="w3-left">
              Pause
            </div>
          </div>
          <div class="w3-button w3-ripple w3-bar w3-green w3-hover-light-green" @click="stop">
            <div class="w3-right">
              <i class="fas fa-stop"></i>
            </div>
            <div class="w3-left">
              Stop/Reset
            </div>
          </div>
          <div class="w3-button w3-ripple w3-bar w3-teal w3-hover-light-green" @click="runNSteps">
            <div class="w3-right">
              <i class="fas fa-step-forward"></i>
            </div>
            <div class="w3-left">
              Step
            </div>
          </div>
          <label>Number of steps ($N$)</label>
          <input class="w3-input w3-border w3-border-blue" type="number" min=2 step=1 v-model.number="sParams.N"
            v-on:blur="validateParams">
          <div class="w3-button w3-ripple w3-bar w3-green w3-hover-light-green" @click="runNSteps(false)">
            <div class="w3-right">
              <i class="fas fa-fast-forward"></i>
            </div>
            <div class="w3-left">
              $N$-steps
            </div>
          </div>
          <input id="sRealtime" class="w3-check" type="checkbox" v-model="sParams.sRealtime">
          <label for="sRealtime">Real time simulation</label>
          <br>
          <input id="showOutputs" class="w3-check" type="checkbox" v-model="sParams.showOuts">
          <label for="showOutputs">Show all the outputs (Not recommended)</label>
        </div>
        <div v-else>
          <h3>Cannot simulate</h3>
          <p>Your browser doesn't support multi threading.</p>
        </div>
      </div>
      <div class="tabContent" style="display: none;" id="folder"></div>
    </div>
    <div id="flex-2" style="overflow:auto;">
      <div id="modelContainer" class="umk_main" style="height:100%;width:100%"></div>
    </div>
  </div>
  <script>
    new ResizeObserver(function () {
      if (graph) graph.umkGridsRefresh();
      if (outln) outln.refresh();
    }).observe(modelContainer);
    var mainSplit = Split(["#flex-1", "#flex-2"], {
      minSize: 0,
      snapOffset: 100,
      sizes: [25, 75],
      gutterSize: 4,
      elementStyle: function (dimension, size, gutterSize) {
        return {
          "flex-basis": "calc(" + size + "% - " + gutterSize + "px)"
        };
      },
      gutterStyle: function (dimension, gutterSize) {
        return {
          "flex-basis": gutterSize + "px"
        };
      }
    });
  </script>
  <div id="statusBar" class="umk_main w3-bar w3-dark-grey w3-tiny">
    <div id="stateOfSystem" class="w3-bar-item w3-right" style="padding: 0px;">Design</div>
    <div class="w3-bar-item w3-right" style="padding: 0px; margin: 0 8px;">
      <i class="fas fa-braille"></i>
    </div>
    <div id="simulationTime" class="w3-bar-item w3-right" style="padding: 0px;">0.000</div>
    <div class="w3-bar-item w3-right" style="padding: 0px;">$t=$</div>
  </div>

  <div id="sToolBar" class="umk_main w3-bar w3-indigo w3-card"
    style="transition: margin 700ms;/*position:fixed;top:0;left:0;display: none;*/">
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="showSimulationToolbar(false)"
      title="Show all blocks (Ctrl+P)&#10;Displays or hides the printer drawer">
      <i class="fa-fw fas fa-arrow-left"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="executeSimulation()"
      title="Show all blocks (Ctrl+P)&#10;Displays or hides the printer drawer">
      <i class="fa-fw fas fa-play"></i>
    </div>
  </div>
  <div id="toolBar" class="umk_main w3-bar w3-indigo w3-card"
    style="transition: margin 700ms;/*position:fixed;top:0;left:0;*/">
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick=""
      title="Show menu (Ctrl+)&#10;Pull the menu drawer.">
      <i class="fa-fw fas fa-bars"></i>
    </div>
    <div class="w3-bar-item" style="padding: 0px;">
      <i class="fa-fw fas fa-ellipsis-v"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;"
      onclick="toggleSideBar('libraryOfBlocks')" title="Add Blocks (Ctrl+B)&#10;Displays or hides the blocks drawer">
      <i class="fa-fw fas fa-th-large"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;"
      onclick="toggleSideBar('editorForParameters')"
      title="Edit block (Ctrl+E)&#10;Displays or hides the editor drawer for blocks.">
      <i class="fa-fw far fa-edit"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;"
      onclick="if (graph.isEnabled()) graph.removeCells();" title="Delete (Del)&#10;Delete the selected blocks.">
      <i class="fa-fw fas fa-trash-alt"></i>
    </div>
    <div class="w3-bar-item" style="padding: 0px;">
      <i class="fa-fw fas fa-ellipsis-v"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;"
      onclick="toggleSideBar('printingTheModel')"
      title="Show all blocks (Ctrl+P)&#10;Displays or hides the printer drawer">
      <i class="fa-fw fas fa-print"></i>
    </div>
    <div class="w3-bar-item w3-button w3-indigo w3-hover-indigo" style="padding: 0px 4px;"
      onclick="displayExecutionOrder()" title="Show all blocks (Ctrl+P)&#10;Displays or hides the printer drawer">
      <i class="fa-fw fas fa-sort-numeric-up-alt"></i>
    </div>
    <div class="w3-bar-item w3-button w3-red w3-hover-indigo" style="padding: 0px 4px;"
      onclick="toggleSideBar('printingTheModel')"
      title="Show all blocks (Ctrl+P)&#10;Displays or hides the printer drawer">
      <i class="fa-fw fas fa-cogs"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="showSimulationToolbar()"
      title="Show all blocks (Ctrl+P)&#10;Displays or hides the printer drawer">
      <i class="fa-fw fas fa-play"></i>
    </div>
    <div class="w3-bar-item" style="padding: 0px;">
      <i class="fa-fw fas fa-ellipsis-v"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="graph.zoomOut()"
      title="Zoom out (Ctrl+minus)&#10;Zooms out the block diagram">
      <i class="fa-fw fas fa-search-minus"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="graph.zoomIn()"
      title="Zoom in (Ctrl+plus)&#10;Zooms in the block diagram">
      <i class="fa-fw fas fa-search-plus"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="graph.zoomActual()"
      title="Zoom 1:1 (Ctrl+0)&#10;Zooms the block diagram to its original size">
      <i class="fa-fw fas fa-compress"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="graph.fit()"
      title="Fit all (Ctrl+1)&#10;Zooms the block diagram to fit the whole whole diagram">
      <i class="fa-fw fas fa-expand"></i>
    </div>
    <div class="w3-bar-item" style="padding: 0px;">
      <i class="fa-fw fas fa-ellipsis-v"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="moveGraph('up')"
      title="Move up (Up arrow)&#10;Moves the graph up">
      <i class="fa-fw fas fa-arrow-up"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="moveGraph('down')"
      title="Move down (Down arrow)&#10;Moves the graph down">
      <i class="fa-fw fas fa-arrow-down"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="moveGraph('left')"
      title="Move left (Left arrow)&#10;Moves the graph left">
      <i class="fa-fw fas fa-arrow-left"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="moveGraph('right')"
      title="Move right (Right arrow)&#10;Moves the graph right">
      <i class="fa-fw fas fa-arrow-right"></i>
    </div>
    <div class="w3-bar-item" style="padding: 0px;">
      <i class="fa-fw fas fa-ellipsis-v"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="undoManager.undo()"
      title="Undo (Ctrl+Z)&#10;Undo the recent changes">
      <i class="fa-fw fas fa-undo"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="undoManager.redo()"
      title="Redo (Ctrl+Shift+Z)&#10;Redo the recent changes">
      <i class="fa-fw fas fa-redo"></i>
    </div>
    <div class="w3-bar-item" style="padding: 0px;">
      <i class="fa-fw fas fa-ellipsis-v"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="createSubModel()"
      title="Group (Ctrl+G)&#10;Group the selected blocks to create a sub-model">
      <i class="fa-fw far fa-object-group"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="ungroupSubModel()"
      title="Ungroup (Ctrl+Shift+G)&#10;Ungroup the selected sub-models">
      <i class="fa-fw far fa-object-ungroup"></i>
    </div>
    <div class="w3-bar-item" style="padding: 0px;">
      <i class="fa-fw fas fa-ellipsis-v"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="foldItems()"
      title="Minimize (Ctrl+M)&#10;Minimize the selected blocks and sub-models">
      <i class="fa-fw fas fa-window-minimize"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="foldItems(false)"
      title="Maximize (Ctrl+Shift+M)&#10;Maximize the selected blocks and sub-models">
      <i class="fa-fw fas fa-window-maximize"></i>
    </div>
  </div>
  <div id="outlineContainer" class="w3-hide-small w3-hide-medium"
    style="position:fixed;overflow:hidden;top:50px;right:5px;width:200px;height:140px;background:transparent;border-style:solid;border-color:black;">
  </div>
  <div id="libraryOfBlocks" class="w3-sidebar w3-animate-left"
    style="z-index: 2; left: 0px; top: 0px; width: 25%;display: none;touch-action: none; border-right: solid 2px black;">
    <div class="w3-block w3-yellow w3-hover-red w3-button" onclick="toggleSideBar('libraryOfBlocks')">
      <div class="w3-right">
        <i class="fas fa-sign-out-alt fa-rotate-180"></i>
      </div>
      <div class="w3-left">
        Close
      </div>
    </div>
  </div>

  <div id="app">
    <div id="waitForProcessToFinish" class="w3-modal w3-display-container">
      <div class="w3-display-middle w3-center w3-padding" style="background-color: #e1e1e180;">
        <p id="DOMWaitingHead" class="w3-large"></p>
        <div class="fa-3x">
          <i class="fas fa-spinner fa-pulse"></i>
        </div>
        <p id="DOMWaitingDesc" class="w3-large"></p>
      </div>
    </div>
  </div>
  <div id="tempSideForAlwaysHidden" style="width:0px;"></div>
  <script>
    function selectTabItem(evt, divName) {
      var i, x, tablinks;
      x = document.getElementsByClassName("tabContent");
      for (i = 0; i < x.length; i++) {
        x[i].style.display = "none";
      }
      tablinks = document.getElementsByClassName("tablink");
      for (i = 0; i < x.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" w3-blue", "");
      }
      document.getElementById(divName).style.display = "block";
      evt.currentTarget.className += " w3-blue";
    }

    function prepareSVGURL(svg) {
      return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    }

    function showSimulationToolbar(show = true) {
      if (show) {
        toggleSideBar();
        document.getElementById("toolBar").style.display = "none";
        document.getElementById("sToolBar").style.display = "block";
      } else {
        stopSimulation();
        document.getElementById("sToolBar").style.display = "none";
        document.getElementById("toolBar").style.display = "block";
      }
    }

    function toggleSideBar(sidebar = "tempSideForAlwaysHidden") {
      var thisSidebar = document.getElementById(sidebar);
      var allTheSidebars = document.getElementsByClassName("w3-sidebar");
      var currentStat = thisSidebar.style.display;
      var allTheMains = document.getElementsByClassName("umk_main");
      //console.log(allTheSidebars[0]);
      for (var i = 0; i < allTheSidebars.length; i++)
        allTheSidebars[i].style.display = "none";
      if (currentStat === "none") thisSidebar.style.display = "block";
      var sizeForMain = document.body.clientWidth - thisSidebar.clientWidth;
      for (var i = 0; i < allTheMains.length; i++) {
        allTheMains[i].style.width = sizeForMain + "px";
        allTheMains[i].style.marginLeft = thisSidebar.clientWidth + "px";
      }
      outln.refresh();
    }
  </script>

  <script>
    //MathJax setup
    MathJax.Hub.Config({
      showMathMenu: false,
      messageStyle: "none",
      menuSettings: {
        inTabOrder: false
      },
      extensions: ["tex2jax.js"],
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        preview: "none",
        inlineMath: [
          ["$", "$"],
          ["\\(", "\\)"]
        ],
        displayMath: [
          ["$$", "$$"],
          ["\\[", "\\]"]
        ]
      }
    });
  </script>
  <script>
    var notyf = new Notyf({
      duration: 10000
    });
  </script>
  <script>
    var LIBRARY_SUMMARY = {};
    var ALLFUNCTIONS = {};
    var fullyLoadedTimeCheck;
  </script>
  <script>
    var simulation = new Vue({
      "el": "#simulation",
      "data": {
        "available": false,
        "sParams": {
          "Ts": 0.1,
          "T_E": 10,
          "N": 2,
          "showOuts": false,
          "sRealtime": true
        },
        "state": "Design",
        "t": 0,
        "timePrecision": 1,
        "threads": {}
      },
      "created": function () {
        this.available = !!Worker;
        var simulationToolForBar = document.getElementById("simulationToolForBar");
        if (this.available) simulationToolForBar.style.display = "block";
        else simulationToolForBar.style.display = "none";
      },
      "watch": {
        "state": function (val) {
          document.getElementById("stateOfSystem").innerHTML = val;
        },
        "t": function (val) {
          document.getElementById("simulationTime").innerHTML = val.toFixed(this.timePrecision);
        }
      },
      "methods": {
        "stop": function () {
          this.state = "Design";
          this.terminateAThread(this.threads.ct);
          delete this.threads.ct;
        },
        "pause": function () {
          this.threads.ct.postMessage({
            "state": "Pause"
          });
        },
        "run": function () {
          if (!this.threads.ct) this.restartComputationThread();
          this.threads.ct.postMessage({
            "sParams": {"T_E": this.sParams.T_E},
            "state": "Run"
          });
          this.state = "Simulating";
        },
        "runNSteps": function (oneStep=true) {
          var N;
          if (oneStep) N = 1;
          else N = this.sParams.N;
          if (!this.threads.ct) this.restartComputationThread();
          this.threads.ct.postMessage({
            "sParams": {"T_E": (N*this.Ts)},
            "state": "Run"
          });
          this.state = "Simulating";
        },
        "terminateAThread": function (umk_thread) {
          if (!!umk_thread) {
            umk_thread.terminate();
          }
        },
        "restartComputationThread": function () {
          //Remove thread if exists
          this.terminateAThread(this.threads.ct);
          //Check if a valid execution order is available
          var order = getExecutionOrder();
          if (order.eo.length <= 0) throw {
            code: "UMK_SM_NO_EO",
            message: "Executing blocks are not available"
          };
          else {
            try {
              //Create a new thread
              this.threads.ct = new Worker("js/simulate.js?date=" + Date.now());
              updateOutputs = [];
              var getResults = [];
              var modelsForExec = [];
              var inputsArray = [];
              for (var i = 0; i < order.eo.length; i++) {
                var tempSources = [];
                getSourcesWithIndexes(order.eo[i]).forEach(function (item) {
                  tempSources.push([order.eo.indexOf(item.model), item.index]);
                });
                //Obtaining execution order
                modelsForExec.push({
                  m: order.eo[i].value,
                  s: tempSources
                });
                //Obtaining inputs array
                //Creating handles to update sinks
                if (order.eo[i].value.Category === "sinks") {
                  getResults[i] = true;
                  if (order.eo[i].value.Icon().output === "display") {
                    updateOutputs[i] = {
                      data: order.eo[i],
                      update: function (val) {
                        this.data.value.show = val;
                        graph.refresh(this.data);
                      }
                    };
                  }
                } else getResults[i] = false;
              }


              this.threads.ct.postMessage({
                em: modelsForExec,
                oa: getResults,
                am: ALLFUNCTIONS,
                sParams: this.sParams,
                state: "start",
                endAt: -1,
                timeStep: 0.1,
                resetTime: true
              });
              this.threads.ct.onmessage = function (event) {
                //console.log(event);
                if ((!!event.data.status) && (event.data.status === "EOS")) simulation.$set(simulation.$data,"state", "Design");
                if (!!event.data.t) simulation.$set(simulation.$data,"t", event.data.t);
                if (!!event.data.out) {
                  for (var i = 0; i < updateOutputs.length; i++) {
                    if (!!updateOutputs[i])
                      updateOutputs[i].update(
                        makeATEXMatrix(event.data.out[i][0][0])
                      );
                  }
                }
              };
            } catch (e) {
              this.terminateAThread(this.threads.ct);
              throw {
                code: "UMK_SM_TCE",
                message: "Error in creating thread. Cannot simulate. Please check your system again. Contact support if this error keeps popping up."
              }
            }
          }
        },
        "validateParams": function () {
          var infArray = ["inf", "infinity", ""];
          this.sParams.Ts = parseFloat(this.sParams.Ts);
          if (isNaN(this.sParams.Ts) || this.sParams.Ts <= 0) this.sParams.Ts = 0.001;
          this.sParams.T_E = parseFloat(this.sParams.T_E);
          if (isNaN(this.sParams.T_E) || this.sParams.T_E <= 0) this.sParams.T_E = Infinity;
          this.sParams.N = parseInt(this.sParams.N);
          if (isNaN(this.sParams.N) || this.sParams.N <= 0) this.sParams.N = 2;
          this.timePrecision = precision(this.sParams.Ts);
        },
        "showExecutionOrder": function () {
          displayExecutionOrder();
        }
      }
    });
  </script>
  <script>
    var mainToobar = new Vue({
      el: "#mainToobar",
      data: {
        visibleItem: "library",
        toolBar: [{
            value: "File",
            icon: "fas fa-arrow-left",
            function: "",
            text: "Good to go when eveything is fine and also I want to say something more 1",
            shortcut: "Ctrl + C",
            items: [{
                value: "New",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 2",
                shortcut: "Ctrl + C"
              },
              {
                value: "Save",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 3",
                shortcut: "Ctrl + C"
              },
              {
                value: "Load",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 4",
                shortcut: "Ctrl + C"
              },
              {
                value: "hl",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 5",
                shortcut: "Ctrl + C"
              },
              {
                value: "Print",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 6",
                shortcut: "Ctrl + C"
              },
              {
                value: "hl",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 7",
                shortcut: "Ctrl + C"
              },
              {
                value: "Account",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 8",
                shortcut: "Ctrl + C"
              },
              {
                value: "Extend licence period",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 9",
                shortcut: "Ctrl + C"
              },
              {
                value: "File explorer",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 10",
                shortcut: "Ctrl + C"
              },
              {
                value: "Sign out",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 11",
                shortcut: "Ctrl + C"
              }
            ]
          },
          {
            value: "Edit",
            icon: "fas fa-arrow-left",
            function: "showSimulationToolbar(false)",
            text: "Good to go when eveything is fine and also I want to say something more 12",
            shortcut: "Ctrl + C",
            items: [{
                value: "Cut",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 13",
                shortcut: "Ctrl + C"
              },
              {
                value: "Copy",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 14",
                shortcut: "Ctrl + C"
              },
              {
                value: "Paste",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 15",
                shortcut: "Ctrl + C"
              },
              {
                value: "hl",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 16",
                shortcut: "Ctrl + C"
              },
              {
                value: "Edit block",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 17",
                shortcut: "Ctrl + C"
              },
              {
                value: "Edit ",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 18",
                shortcut: "Ctrl + C"
              }
            ]
          },
          {
            value: "View",
            icon: "fas fa-arrow-left",
            function: "showSimulationToolbar(false)",
            text: "Good to go when eveything is fine and also I want to say something more 19",
            shortcut: "Ctrl + C",
            items: [{
                value: "Zoom in",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 20",
                shortcut: "Ctrl + C"
              },
              {
                value: "Zoom out",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 21",
                shortcut: "Ctrl + C"
              },
              {
                value: "Original size",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 22",
                shortcut: "Ctrl + C"
              },
              {
                value: "Fit all",
                icon: "fas fa-arrow-left",
                function: "showSimulationToolbar(false)",
                text: "Good to go when eveything is fine and also I want to say something more 23",
                shortcut: "Ctrl + C"
              }
            ]
          }
        ]
      }
    });
  </script>
  <script>
    var printingTheModel = new Vue({
      el: "#printingTheModel",
      data: {
        addStartPages: [],
        addEndPages: [],
        title: "Uyamak model",
        orientation: {
          value: "portrait",
          options: {
            portrait: "Portrait",
            landscape: "Landscape"
          }
        },
        pageSize: {
          value: "letter",
          options: {
            letter: "Letter",
            a4: "A4"
          }
        },
        fit: {
          force: false,
          numberOfPages: 1
        }
      },
      methods: {
        prepareMPDoc: function () {
          graph.setSelectionCell();
          var scale = 1;
          this.fit.numberOfPages = Math.round(this.fit.numberOfPages);
          if (this.fit.numberOfPages < 1) this.fit.numberOfPages = 1;
          if (this.fit.force)
            scale = mxUtils.getScaleForPageCount(
              this.fit.numberOfPages,
              graph
            );
          var preview = new mxPrintPreview(graph, scale);
          preview.title = this.title;
          if (
            this.orientation.value === "portrait" &&
            this.pageSize.value === "letter"
          )
            preview.pageFormat = mxConstants.PAGE_FORMAT_LETTER_PORTRAIT;
          if (
            this.orientation.value === "portrait" &&
            this.pageSize.value === "a4"
          )
            preview.pageFormat = mxConstants.PAGE_FORMAT_A4_PORTRAIT;
          if (
            this.orientation.value === "landscape" &&
            this.pageSize.value === "letter"
          )
            preview.pageFormat = mxConstants.PAGE_FORMAT_LETTER_LANDSCAPE;
          if (
            this.orientation.value === "landscape" &&
            this.pageSize.value === "a4"
          )
            preview.pageFormat = mxConstants.PAGE_FORMAT_A4_LANDSCAPE;
          //console.log(preview.pageFormat);

          var defaultWriteHead = mxPrintPreview.prototype.writeHead;
          preview.writePostfix = function (doc) {
            defaultWriteHead.apply(this, arguments);
            doc.writeln(
              '<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"><\/script>'
            );
            doc.writeln("<script>");
            doc.writeln(
              'MathJax.Hub.Config({showMathMenu:false,messageStyle:"none",menuSettings:{inTabOrder:false},extensions:["tex2jax.js"],jax:["input/TeX","output/HTML-CSS"],tex2jax:{preview:"none",inlineMath:[["$","$"],["\\\\(","\\\\)"]],displayMath:[["\$\$","\$\$"],["\\\\[","\\\\]"]]}});'
            );
            doc.writeln("<\/script>");
            //return doc;
          };
          preview.open();
        }
      }
    });
  </script>
  <script>
    var editBlocksApp = new Vue({
      updated: function () {
        MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
      },
      el: "#editorForParameters",
      data: {
        uyamakModel: null,
        cellModel: {
          model: false,
          value: null
        },
        invalidInputs: [],
        parametersDisplay: null,
        updatingCounter: 0
      },
      computed: {
        parametersValidationComments: function () {
          return this.uyamakModel.ValidateParams();
        },
        inputErrors: function () {
          return (
            "<table class='w3-table'>" +
            this.invalidInputs
            .map(function (currentValue, index, arr) {
              return (
                "<tr><td>" +
                editBlocksApp.$data.uyamakModel.Parameters[
                  parseInt(currentValue.split(",")[0])
                ].Name +
                " at [" +
                (parseInt(currentValue.split(",")[1]) + 1) +
                ", " +
                (parseInt(currentValue.split(",")[2]) + 1) +
                "]" +
                "</td></tr>"
              );
            })
            .join("") +
            "</table>"
          );
        }
      },
      methods: {
        rotate: function (ang) {
          var pConstarins = [];
          pConstarins[0] = {
            in: "west",
            out: "east"
          };
          pConstarins[90] = {
            in: "north",
            out: "south"
          };
          pConstarins[180] = {
            in: "east",
            out: "west"
          };
          pConstarins[270] = {
            in: "south",
            out: "north"
          };
          graph.setCellStyles(
            "rotation",
            ang,
            [graph.getSelectionCell()].concat(
              graph.getSelectionCell().children
            )
          );
          for (var i = 0; i < graph.getSelectionCell().children.length; i++) {
            if (
              graph
              .getSelectionCell()
              .children[i].style.search("umk_input") >= 0
            )
              graph.setCellStyles("portConstraint", pConstarins[ang].in, [
                graph.getSelectionCell().children[i]
              ]);
            if (
              graph
              .getSelectionCell()
              .children[i].style.search("umk_output") >= 0
            )
              graph.setCellStyles("portConstraint", pConstarins[ang].out, [
                graph.getSelectionCell().children[i]
              ]);
          }
        },
        applyCellValue: function () {
          if (
            graph.getSelectionCell().isEdge() ||
            graph.getSelectionCell().style.search("umk_group") >= 0
          ) {
            graph.getSelectionCell().value = this.cellModel.value;
            graph.refresh(graph.getSelectionCell());
          }
        },
        saveModel: function () {
          //Adding model to the Block
          eval(
            "var tempModel = new umk_" +
            this.uyamakModel.bid +
            "(this.uyamakModel);"
          );
          graph.getSelectionCell().setValue(tempModel);
          setTermianls(graph.getSelectionCell(), "umk_input");
          setTermianls(graph.getSelectionCell(), "umk_output");
          graph.refresh(graph.getSelectionCell());
        },
        getBlockDetails: function () {
          try {
            return this.uyamakModel.Details();
          } catch (e) {
            console.log(e);
            return "UNKNOWN ERROR!!!. If this error continues, please contact the support.";
          }
        },
        toggleParamDisplay: function (index) {
          //console.log(this.parametersDisplay);
          this.updatingCounter++;
          this.parametersDisplay[index] = !this.parametersDisplay[index];
        },
        validateParamCellEntry: function (index, index1, index2) {
          var tempValidateItem = index + "," + index1 + "," + index2;
          var outValue;
          var tempValue = this.uyamakModel.Parameters[index].Value[index1][
            index2
          ];
          try {
            switch (this.uyamakModel.Parameters[index].Type) {
              case "Integer":
                outValue =
                  typeof math.evaluate(tempValue) === "number" &&
                  math.evaluate(tempValue) % 1 === 0;
                break;
              case "Real":
                outValue = typeof math.evaluate(tempValue) === "number";
                break;
              case "Complex":
                outValue =
                  math.evaluate(tempValue).type === "Complex" ||
                  typeof math.evaluate(tempValue) === "number";
                break;
              case "Text":
              case "Color":
              case "Option":
                outValue = tempValue !== "" && tempValue !== null;
                break;
            }
          } catch (e) {
            console.log(e);
            outValue = false;
          }
          var tempIndex = this.invalidInputs.indexOf(tempValidateItem);
          if (outValue) {
            if (tempIndex >= 0) this.invalidInputs.splice(tempIndex, 1);
          } else {
            if (tempIndex < 0) this.invalidInputs.push(tempValidateItem);
          }
          return outValue;
        },
        valueDimensionsModify: function (func, index) {
          var tempItem;
          switch (this.uyamakModel.Parameters[index].Type) {
            case "Integer":
            case "Real":
            case "Complex":
              tempItem = 0;
              break;
            case "Text":
              tempItem = "";
              break;
            case "Color":
              tempItem = "Black";
              break;
          }
          switch (func) {
            case 0:
              this.uyamakModel.Parameters[index].Value.push(
                new Array(
                  this.uyamakModel.Parameters[index].Value[0].length
                ).fill(tempItem)
              );
              break;
            case 1:
              if (this.uyamakModel.Parameters[index].Value.length > 1)
                this.uyamakModel.Parameters[index].Value.pop();
              break;
            case 2:
              this.uyamakModel.Parameters[index].Value.map(function (val) {
                return val.push(tempItem);
              });
              break;
            case 3:
              if (this.uyamakModel.Parameters[index].Value[0].length > 1) {
                this.uyamakModel.Parameters[index].Value.map(function (val) {
                  return val.pop();
                });
              }
              break;
          }
          this.updatingCounter++;
        }
      }
    });
  </script>
  <script>
    function selectionChanged() {
      if (
        graph.getSelectionCell() &&
        graph.getSelectionCell().isVertex() &&
        typeof graph.getSelectionCell().value === "object"
      ) {
        changeEditModelWithSelectedBlock();
      } else {
        editBlocksApp.$set(editBlocksApp.$data, "uyamakModel", null);
        if (
          graph.getSelectionCell() &&
          (graph.getSelectionCell().isEdge() ||
            graph.getSelectionCell().style.search("umk_group") >= 0)
        ) {
          editBlocksApp.$set(editBlocksApp.$data, "cellModel", {
            model: true,
            value: graph.getSelectionCell().value || ""
          });
        } else {
          editBlocksApp.$set(editBlocksApp.$data, "cellModel", {
            model: false,
            value: null
          });
        }
      }
    }

    function changeEditModelWithSelectedBlock() {
      eval(
        "var editModel = new umk_" +
        graph.getSelectionCell().value.bid +
        "(graph.getSelectionCell().value);"
      );
      editBlocksApp.$set(editBlocksApp.$data, "uyamakModel", editModel);
      editBlocksApp.$set(
        editBlocksApp.$data,
        "parametersDisplay",
        new Array(editModel.Parameters.length).fill(false)
      );
      editBlocksApp.$set(editBlocksApp.$data, "cellModel", {
        model: false,
        value: null
      });
    }
  </script>

  <script>
    function holdToFinishAProcess(title = null, description = null) {
      if (title)
        document.getElementById("waitForProcessToFinish").style.display =
        "block";
      else
        document.getElementById("waitForProcessToFinish").style.display =
        "none";
      if (title) document.getElementById("DOMWaitingHead").innerText = title;
      if (description)
        document.getElementById("DOMWaitingDesc").innerText = description;
    }
    holdToFinishAProcess(
      "Connecting to the server.",
      "Please wait while loading the app. If this process takes longer than a minute, check your internet connection and refresh the page."
    );
  </script>
  <script>
    var TempRecAttempt;
    var functions = firebase.functions();
    var db = firebase.firestore();
    const settings = {
      timestampsInSnapshots: true
    };
    db.settings(settings);
    var validateUserSession = firebase
      .functions()
      .httpsCallable("validateUserSession");
    firebase.auth().onAuthStateChanged(function (user) {
      holdToFinishAProcess("Loading the app.");
      TempRecAttempt = setInterval(function () {
        //console.log("attempt");
        if (app) {
          holdToFinishAProcess("Verifying the license.");
          clearInterval(TempRecAttempt);
          user ? handleSignedInUser(user) : handleSignedOutUser();
        }
      }, 500);
    });

    function handleSignedInUser(user) {
      validateUserSession().then(function (result) {
        //console.log(result.data.isSuccess);
        if (result.data.isSuccess) loadTheGUI();
        else
          window.location.replace(
            "/platform/admin?redirect=" + location.pathname
          );
      });
    }

    function handleSignedOutUser() {
      window.location.replace("/sign-in?redirect=" + location.pathname);
    }

    function loadTheGUI() {
      //app.$set(app.$data.user, "uid", firebase.auth().currentUser.uid);
      /*app.$set(
        app.$data.user,
        "photoURL",
        firebase.auth().currentUser.photoURL
      );*/
      db.collection("blocks-summary")
        .get()
        .then(function (querySnapshot) {
          querySnapshot.forEach(function (doc) {
            db.collection("blocks-summary")
              .doc(doc.id)
              .get()
              .then(function (doc) {
                var dbData = doc.data();
                LIBRARY_SUMMARY[doc.id] = dbData;
                //console.log(doc.id, " => ", dbData);
                /*if (!app.$data.blocksSummary)
                  app.$set(app.$data, "blocksSummary", {});
                app.$set(app.$data.blocksSummary, doc.id, dbData);*/
                var headDiv = document.createElement("div");
                headDiv.classList.add("w3-theme-d2");
                headDiv.classList.add("w3-hover-blue");
                headDiv.style.cursor = "pointer";
                headDiv.innerHTML =
                  "<span><i class='fas fa-caret-down fa-fw'></i></span><span>" +
                  dbData.name +
                  "</span>";
                var bodyDiv = document.createElement("div");
                bodyDiv.style.display = "block";
                for (var key in dbData.blocks) {
                  addANewDraggableIcon(
                    bodyDiv,
                    Object.assign({
                        key: key,
                        colors: dbData.colors
                      },
                      dbData.blocks[key]
                    )
                  );
                }
                sortTheDoms(bodyDiv);
                var summDiv = document.createElement("div");
                summDiv.setAttribute(
                  "id",
                  "blocks_" + dbData.order + "for_" + doc.id
                );
                headDiv.addEventListener("click", function () {
                  if (bodyDiv.style.display === "block") {
                    bodyDiv.style.display = "none";
                    headDiv.firstElementChild.innerHTML =
                      "<i class='fas fa-caret-right fa-fw'></i>";
                  } else {
                    bodyDiv.style.display = "block";
                    headDiv.firstElementChild.innerHTML =
                      "<i class='fas fa-caret-down fa-fw'></i>";
                  }
                });
                summDiv.appendChild(headDiv);
                summDiv.appendChild(bodyDiv);
                document.getElementById("blocksBar").appendChild(summDiv);
                sortTheDoms(document.getElementById("blocksBar"));
              })
              .catch(function (error) {
                console.log("Error getting cached document:", error);
              });
          });
        });
      main(
        document.getElementById("modelContainer"),
        document.getElementById("outlineContainer")
      );
      fullyLoadedTimeCheck = setInterval(function () {
        if (Object.keys(LIBRARY_SUMMARY).length === 7) {
          holdToFinishAProcess(false);
          clearInterval(fullyLoadedTimeCheck);
        }
      }, 1000);
    }

    function sortTheDoms(list) {
      var items = list.childNodes;
      var itemsArr = [];
      for (var i in items) {
        if (items[i].nodeType == 1) {
          // get rid of the whitespace text nodes
          itemsArr.push(items[i]);
        }
      }

      itemsArr.sort(function (a, b) {
        return a.id === b.id ? 0 : a.id > b.id ? 1 : -1;
      });

      for (i = 0; i < itemsArr.length; ++i) {
        list.appendChild(itemsArr[i]);
      }
    }

    var iconText = {
      icon1: "<svg viewBox='-3 -3 106 106' xmlns='http://www.w3.org/2000/svg'><defs><filter id='f0' x='-50%' y='-50%' width='200%' height='200%'><feGaussianBlur in='SourceAlpha' stdDeviation='1'/><feOffset dx='0' dy='0' result='offsetblur'/><feMerge><feMergeNode/><feMergeNode in='SourceGraphic'/></feMerge></filter><filter id='f1' x='-50%' y='-50%' width='200%' height='200%'><feOffset result='offOut' in='SourceAlpha' dx='3' dy='3' /><feGaussianBlur result='blurOut' in='offOut' stdDeviation='1' /><feBlend in='SourceGraphic' in2='blurOut' mode='normal' /></filter></defs><g><rect rx='0' height='100' width='100' y='0' x='0' stroke-width='0' fill='",
      icon2: "' filter='url(#f0)'/></g><g stroke-linecap='round' filter='url(#f1)' width='100' height='100' stroke='",
      icon3: "' stroke-width='10' fill='none'>",
      icon4: "</g></svg>"
    };

    function getIconWith(colors, path) {
      return (
        iconText.icon1 +
        colors.bg +
        iconText.icon2 +
        "#ffffff" +
        iconText.icon3 +
        path +
        iconText.icon4
      );
    }

    function svgTextToURL(svg) {
      svg = svg;
      let tempBlob = new Blob([svg], {
        type: "image/svg+xml"
      });
      let url = URL.createObjectURL(tempBlob);
      return url;
    }

    const blockTemplate = [{
        name: "Category",
        type: "string",
        argument: ""
      },
      {
        name: "Name",
        type: "string",
        argument: ""
      },
      {
        name: "Description",
        type: "string",
        argument: ""
      },
      {
        name: "Parameters",
        type: "json",
        argument: ""
      },
      {
        name: "Label",
        type: "function",
        argument: ""
      },
      {
        name: "Icon",
        type: "function",
        argument: ""
      },
      {
        name: "Init",
        type: "function",
        argument: ""
      },
      {
        name: "End",
        type: "function",
        argument: ""
      },
      {
        name: "Constructor",
        type: "function",
        argument: "Data"
      },
      {
        name: "Destructor",
        type: "function",
        argument: "Data"
      },
      {
        name: "RunTimeExec",
        type: "function",
        argument: ""
      },
      {
        name: "Evaluate",
        type: "function",
        argument: ""
      },
      {
        name: "Details",
        type: "function",
        argument: ""
      },
      {
        name: "ValidateParams",
        type: "function",
        argument: ""
      },
      {
        name: "bid",
        type: "string",
        argument: ""
      },
      {
        name: "Colors",
        type: "object",
        argument: ""
      },
      {
        name: "TerminalsIn",
        type: "object",
        argument: ""
      },
      {
        name: "TerminalsOut",
        type: "object",
        argument: ""
      }
    ];

    function loadABlock() {
      holdToFinishAProcess("Downloading the block from server");
      try {
        if (!BLOCKS_LIB || !BLOCKS_LIB[app.$data.bid]) {
          db.collection("blocks")
            .doc(app.$data.bid)
            .get()
            .then(function (doc) {
              holdToFinishAProcess("Loading block's functionaliy");
              if (doc.exists) {
                convertDBDataToModel(doc.id, doc.data());
                assignDataToNode(BLOCKS_LIB[app.$data.bid]);
              } else throw "Uyamak: Block Not found";
            });
        } else {
          assignDataToNode(BLOCKS_LIB[app.$data.bid]);
        }
      } catch (e) {
        console.log(e);
        GSK_CALLBACK(null);
        exitEditMode();
        holdToFinishAProcess(false);
        notyf.error("Error in adding this block.");
      }
    }

    function createIconForNetwork(cid, iconText) {
      return (
        "data:image/svg+xml;charset=utf-8," +
        encodeURIComponent(
          app.$data.networkIcon.icon1 +
          app.$data.blocksSummary[cid].colors.bg +
          app.$data.networkIcon.icon2 +
          "#ffffff" +
          app.$data.networkIcon.icon3 +
          iconText +
          app.$data.networkIcon.icon4
        )
      );
    }

    function createCopyOfModel(inModel) {
      var outValue = JSON.parse2(JSON.stringify2(inModel));
      blockTemplate.forEach(function (item) {
        if (item.type === "function") {
          outValue[item.name] = inModel[item.name];
        }
      });
      return outValue;
    }

    function assignDataToNode(inModel) {
      GSK_DATA.uyamakModel = createCopyOfModel(inModel);
      GSK_DATA.uyamakModel.Constructor(GSK_DATA);
      var tempIconData = GSK_DATA.uyamakModel.Icon();
      GSK_DATA.shape = tempIconData.shape;
      if (GSK_DATA.shape === "image")
        GSK_DATA.image = createIconForNetwork(
          GSK_DATA.uyamakModel.Category,
          tempIconData.icon
        );
      else {
        var tempColors = app.getColorsForTheCategory();
        GSK_DATA.font = {
          color: "#ffffff",
          background: tempColors.bg,
          face: "Courier New",
          size: 30
        };
      }
      GSK_DATA.label = GSK_DATA.uyamakModel.Label();
      GSK_DATA.title = GSK_DATA.uyamakModel.Details();
      GSK_CALLBACK(GSK_DATA);
      exitEditMode();
      holdToFinishAProcess(false);
    }

    function convertDBDataToModel(bid, dbBlockData) {
      BLOCKS_LIB[bid] = {};
      blockTemplate.forEach(function (item) {
        let tempObj = {};
        switch (item.type) {
          case "float":
            if (!dbBlockData[item.name]) tempObj[item.name] = 0;
            else tempObj[item.name] = parseFloat(dbBlockData[item.name]);
            Object.assign(BLOCKS_LIB[bid], tempObj);
            break;
          case "string":
            if (!dbBlockData[item.name]) tempObj[item.name] = "";
            else tempObj[item.name] = dbBlockData[item.name].toString();
            Object.assign(BLOCKS_LIB[bid], tempObj);
            break;
          case "function":
            if (!dbBlockData[item.name]) tempObj[item.name] = "";
            else tempObj[item.name] = dbBlockData[item.name].toString();
            tempObj[item.name] = eval(
              "(function (" +
              item.argument +
              "){" +
              dbBlockData[item.name] +
              "})"
            );
            Object.assign(BLOCKS_LIB[bid], tempObj);
            break;
          case "json":
            if (!dbBlockData[item.name]) tempObj[item.name] = [];
            else tempObj[item.name] = JSON.parse(dbBlockData[item.name]);
            Object.assign(BLOCKS_LIB[bid], tempObj);
            break;
        }
      });
    }

    function pullDBAndGenModel(bid, storeData = null) {
      return new Promise(function (resolve, reject) {
        if (eval("typeof umk_" + bid) === "function") {
          resolve(storeData);
        } else {
          db.collection("blocks")
            .doc(bid)
            .get()
            .then(function (doc) {
              if (doc.exists) {
                createAModel(doc.id, doc.data());
                resolve();
              }
            })
            .catch(function (e) {
              console.log(e);
              notyf.error(
                "Unable to load the block. If your internet connection is not a problem, please contact the support."
              );
              reject();
            });
        }
      });
    }

    function createAModel(bid, dbBlockData) {
      var constructorStr = "umk_" + bid + " = function(obj={}){";
      var prototypesArr = [];
      blockTemplate.forEach(function (item) {
        let tempObj = {};
        var tempVal;
        switch (item.type) {
          case "float":
            if (!dbBlockData[item.name]) tempVal = 0;
            else tempVal = parseFloat(dbBlockData[item.name]);
            constructorStr +=
              "this." + item.name + "=" + tempVal.toString() + ";";
            break;
          case "string":
            if (!dbBlockData[item.name]) tempVal = "";
            else tempVal = dbBlockData[item.name].toString();
            constructorStr +=
              "this." + item.name + '="' + tempVal.toString() + '";';
            break;
          case "json":
            //console.log(dbBlockData[item.name]);
            if (!dbBlockData[item.name]) tempVal = [];
            else tempVal = JSON.parse(dbBlockData[item.name]);
            constructorStr +=
              "this." + item.name + "=" + JSON.stringify(tempVal) + ";";
            break;
          case "object":
            if (!dbBlockData[item.name]) tempVal = {};
            else tempVal = dbBlockData[item.name];
            constructorStr +=
              "this." + item.name + "=" + JSON.stringify(tempVal) + ";";
            break;
          case "function":
            if (!dbBlockData[item.name]) tempVal = "";
            else tempVal = dbBlockData[item.name].toString();
            prototypesArr.push(
              "umk_" +
              bid +
              ".prototype." +
              item.name +
              "=function(" +
              item.argument +
              "){" +
              tempVal +
              "}"
            );
            break;
        }
      });
      constructorStr +=
        "for(var prop in obj){if (typeof obj[prop] !== 'function') this[prop] = JSON.parse2(JSON.stringify2(obj[prop]));}";
      constructorStr += "}";
      eval("window." + constructorStr);
      for (var i = 0; i < prototypesArr.length; i++) {
        eval("window." + prototypesArr[i]);
      }
      ALLFUNCTIONS["umk_" + bid] = {
        cs: constructorStr,
        ps: prototypesArr
      };
      //console.log(constructorStr);
    }
  </script>
  <script>
    function displayExecutionOrder() {
      var allTheModels = getAllTheModels();
      showExecutionOrderMessage(allTheModels, "Ignored: NC");
      var executionOrderAndErros = getExecutionOrder();
      var executionOrder = executionOrderAndErros.eo;
      for (var i = 0; i < executionOrder.length; i++) {
        showExecutionOrderMessage([executionOrder[i]], "EO: " + (i + 1));
      }
      showExecutionOrderMessage(
        executionOrderAndErros.al,
        "Ignored: Possible AL",
        "Ignored: Possible AL"
      );
      showExecutionOrderMessage(executionOrderAndErros.ne, "Ignored: Error");
      showExecutionOrderMessage(executionOrderAndErros.pc, "Ignored: PC");
      graph.refresh();
    }

    function getExecutionOrder() {
      var firstModels = [];
      var allConnectedModels = getAllConnectedModels();
      var fullyConnectedModels = allConnectedModels.fc;
      var aLoopModels = [];

      //Obtaining first executing models
      for (var i = 0; i < fullyConnectedModels.length; i++) {
        if (
          fullyConnectedModels[i].value.TerminalsIn.max === 0 ||
          !!fullyConnectedModels[i].value.FirstInExecutionOrder
        ) {
          firstModels.push(fullyConnectedModels[i]);
        }
      }
      //removing first executing models from fullyConnectedModels
      for (var i = 0; i < firstModels.length; i++) {
        fullyConnectedModels = arrayRemove(
          fullyConnectedModels,
          firstModels[i]
        );
      }
      var ExecutionOrder = firstModels.slice();
      var i = 0;
      try {
        while (fullyConnectedModels.length > 0) {
          var mSources = getSourcesOfAModel(fullyConnectedModels[i]);
          var addThisToOrder = true;
          for (var j = 0; j < mSources.length; j++) {
            if (ExecutionOrder.indexOf(mSources[j]) < 0) {
              addThisToOrder = false;
            }
          }
          if (addThisToOrder) {
            ExecutionOrder.push(fullyConnectedModels[i]);
            fullyConnectedModels = arrayRemove(
              fullyConnectedModels,
              fullyConnectedModels[i]
            );
            i = 0;
          } else {
            i++;
          }
          if (
            fullyConnectedModels.length > 0 &&
            i >= fullyConnectedModels.length
          ) {
            for (var j = 0; j < ExecutionOrder.length; j++) {
              var targets = getTargetsOfAModel(ExecutionOrder[j]);
              for (var k = 0; k < targets.length; k++) {
                if (fullyConnectedModels.indexOf(targets[k]) >= 0) {
                  aLoopModels.push(targets[k]);
                  fullyConnectedModels = arrayRemove(
                    fullyConnectedModels,
                    targets[k]
                  );
                }
              }
            }
            if (aLoopModels.length > 0)
              throw {
                code: "UMKEOAL",
                message: "arthematic loop(s) found"
              };
            else
              throw {
                code: "UMKEOIC",
                message: "Incomplete/improper connections detected"
              };
          }
        }
      } catch (e) {
        if (e.code === "UMKEOAL") {
          notyf.error(e.message);
        } else {
          notyf.error("Unknown error in obtaining the execution order");
        }
      }
      return {
        eo: ExecutionOrder,
        ne: fullyConnectedModels,
        al: aLoopModels,
        pc: allConnectedModels.pc
      };
    }

    function getSourcesOfAModel(inModel) {
      var modelSources = [];
      for (var i = 0; i < inModel.children.length; i++) {
        if (inModel.children[i].style.search("umk_input") >= 0) {
          try {
            if (
              modelSources.indexOf(
                inModel.children[i].edges[0].source.parent
              ) < 0
            )
              modelSources.push(inModel.children[i].edges[0].source.parent);
          } catch (e) {}
        }
      }
      return modelSources;
    }

    function getTargetsOfAModel(inModel) {
      var modelTargets = [];
      for (var i = 0; i < inModel.children.length; i++) {
        if (inModel.children[i].style.search("umk_output") >= 0) {
          for (var j = 0; j < inModel.children[i].edges.length; j++) {
            try {
              if (
                modelTargets.indexOf(
                  inModel.children[i].edges[j].target.parent
                ) < 0
              )
                modelTargets.push(inModel.children[i].edges[j].target.parent);
            } catch (e) {}
          }
        }
      }
      return modelTargets;
    }

    function getAllTheModels() {
      var parent = graph.getDefaultParent();
      var allTheBlocks = [];
      if (graph.getDefaultParent().children) {
        allTheBlocks = allTheBlocks.concat(graph.getDefaultParent().children);
      }
      for (var i = 0; i < allTheBlocks.length; i++) {
        if (allTheBlocks[i].children) {
          allTheBlocks = allTheBlocks.concat(allTheBlocks[i].children);
        }
      }
      var allTheModels = [];
      for (var i = 0; i < allTheBlocks.length; i++) {
        if (
          allTheBlocks[i].isVertex() &&
          typeof allTheBlocks[i].value == "object"
        )
          allTheModels.push(allTheBlocks[i]);
      }
      return allTheModels;
    }

    function getAllConnectedModels() {
      var parent = graph.getDefaultParent();
      var allTheBlocks = [];
      if (graph.getDefaultParent().children) {
        allTheBlocks = allTheBlocks.concat(graph.getDefaultParent().children);
      }
      for (var i = 0; i < allTheBlocks.length; i++) {
        if (allTheBlocks[i].children) {
          allTheBlocks = allTheBlocks.concat(allTheBlocks[i].children);
        }
      }
      var allTheValidEdges = [];
      for (var i = 0; i < allTheBlocks.length; i++) {
        if (
          allTheBlocks[i].isEdge() &&
          typeof allTheBlocks[i].source.parent.value == "object" &&
          typeof allTheBlocks[i].target.parent.value == "object"
        )
          allTheValidEdges.push(allTheBlocks[i]);
      }
      var allConnectedBlocks = [];
      for (var i = 0; i < allTheValidEdges.length; i++) {
        if (
          allConnectedBlocks.indexOf(allTheValidEdges[i].source.parent) < 0
        ) {
          allConnectedBlocks.push(allTheValidEdges[i].source.parent);
        }
        if (
          allConnectedBlocks.indexOf(allTheValidEdges[i].target.parent) < 0
        ) {
          allConnectedBlocks.push(allTheValidEdges[i].target.parent);
        }
      }
      var allFullyConnectedBlocks = [];
      var allPartiallyConnectedBlocks = [];
      for (var i = 0; i < allConnectedBlocks.length; i++) {
        var isFullyConnected = true;
        for (var j = 0; j < allConnectedBlocks[i].children.length; j++) {
          if (
            (allConnectedBlocks[i].children[j].style.search("umk_input") >=
              0 ||
              allConnectedBlocks[i].children[j].style.search("umk_input") >=
              0) &&
            (!allConnectedBlocks[i].children[j].edges ||
              allConnectedBlocks[i].children[j].edges.length < 1)
          )
            isFullyConnected = false;
        }
        if (isFullyConnected)
          allFullyConnectedBlocks.push(allConnectedBlocks[i]);
        else allPartiallyConnectedBlocks.push(allConnectedBlocks[i]);
      }

      return {
        ac: allConnectedBlocks,
        fc: allFullyConnectedBlocks,
        pc: allPartiallyConnectedBlocks
      };
    }

    function showExecutionOrderMessage(cells, message, warning) {
      for (var i = 0; i < cells.length; i++) {
        for (var j = 0; j < cells[i].children.length; j++) {
          if (cells[i].children[j].style.search("umk_EO") >= 0) {
            cells[i].children[j].setValue(message);
          }
        }
        graph.setCellWarning(cells[i], warning);
      }
    }

    function arrayRemove(arr, value) {
      return arr.filter(function (ele) {
        return ele != value;
      });
    }
  </script>
  <script>
    var w;
    var updateOutputs = [];

    function executeSimulation() {
      if (typeof Worker !== "undefined") {
        if (!w) {
          try {
            w = new Worker("js/simulate.js?date=" + Date.now());
            var order = getExecutionOrder();
            var getResults = [];
            var modelsForExec = [];
            var inputsArray = [];
            for (var i = 0; i < order.eo.length; i++) {
              var tempSources = [];
              getSourcesWithIndexes(order.eo[i]).forEach(function (item) {
                tempSources.push([order.eo.indexOf(item.model), item.index]);
              });
              //Obtaining execution order
              modelsForExec.push({
                m: order.eo[i].value,
                s: tempSources
              });

              //Obtaining inputs array
              //Creating handles to update sinks
              if (order.eo[i].value.Category === "sinks") {
                getResults[i] = true;
                if (order.eo[i].value.Icon().output === "display") {
                  updateOutputs[i] = {
                    data: order.eo[i],
                    update: function (val) {
                      this.data.value.show = val;
                      graph.refresh(this.data);
                    }
                  };
                }
              } else getResults[i] = false;
            }
            w.postMessage({
              em: modelsForExec,
              oa: getResults,
              am: ALLFUNCTIONS,
              state: "start",
              endAt: -1,
              timeStep: 0.1,
              resetTime: true
            });
            w.onmessage = function (event) {
              if (!!event.data.out) {
                for (var i = 0; i < updateOutputs.length; i++) {
                  if (!!updateOutputs[i])
                    updateOutputs[i].update(
                      makeATEXMatrix(event.data.out[i][0][0])
                    );
                }
              }
              console.log(event.data);
            };
          } catch (e) {
            console.log(e);
            stopSimulation();
          }
        }
      } else {
        notyf.error("Your browser doesn't support multi-threading.");
      }
    }

    function stopSimulation() {
      if (!!w) {
        w.terminate();
        w = null;
      }
    }

    function getSourcesWithIndexes(inModel) {
      var modelSources = [];
      var indexes = [];
      for (var i = 0; i < inModel.children.length; i++) {
        if (inModel.children[i].style.search("umk_input") >= 0) {
          var index = -1;
          var tempPModel = inModel.children[i].edges[0].source.parent;
          for (j = 0; j < tempPModel.children.length; j++) {
            if (tempPModel.children[j].style.search("umk_output") >= 0) {
              index++;
              if (
                !!tempPModel.children[j].edges &&
                tempPModel.children[j].edges.indexOf(
                  inModel.children[i].edges[0]
                ) >= 0
              ) {
                indexes.push({
                  model: inModel.children[i].edges[0].source.parent,
                  index: index
                });
              }
            }
          }
        }
      }
      return indexes;
    }

    function makeATEXMatrix(inArray) {
      if (inArray.length === 1 && inArray[0].length === 1) {
        return "$" + inArray[0][0] + "$";
      }
      var StrOut = "$\\begin{bmatrix}\n";
      for (var i = 0; i < inArray.length; i++) {
        for (var j = 0; j < inArray[0].length; j++) {
          if (j !== 0) StrOut += "\t&\t";
          StrOut += math.round(math.evaluate(inArray[i][j]), 3);
        }
        StrOut += "\t\\\\\n";
      }
      StrOut += "\\end{bmatrix}$";
      return StrOut;
    }
    function precision(a) {
      if (!isFinite(a)) return 0;
      var e = 1, p = 0;
      while (Math.round(a * e) / e !== a) { e *= 10; p++; }
      return p;
    }
  </script>
</body>

</html>