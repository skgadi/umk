<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>UYAMAK platform</title>
  <link rel="manifest" href="manifest.json" />
  <script src="https://www.gstatic.com/firebasejs/5.5/firebase.js"></script>
  <script src="js/config.js"></script>
  <script src="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.js"></script>
  <link type="text/css" rel="stylesheet" href="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css" />
  <!--link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-w3schools.css"-->
  <link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-teal.css" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
    integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous" />

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.4.0.min.js"
    integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/6.0.3/math.min.js"
    integrity="sha256-TNeqgLgUT/0XFsg+YaC13WI8OyU2S9E5/5P79536W6A=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
  <script src="/js/augmented-json-serialization-functions.js"></script>
  <link rel="stylesheet" href="/css/notyf.min.css" />
  <script src="/js/notyf.min.js"></script>
  <script src="/js/vue.min.js"></script>

  <!-- Sets the basepath for the library if not in same directory -->
  <script type="text/javascript">
    mxBasePath = "/javascript/src";
  </script>

  <!-- Loads and initializes the library -->
  <script type="text/javascript" src="/javascript/src/js/mxClient.js"></script>

  <script type="text/javascript">
    var graph;
    var undoManager;
    var tempGlobal;
    var outln;
    // Program starts here. Creates a sample graph in the
    // DOM node with the specified ID. This function is invoked
    // from the onLoad event handler of the document (see below).
    function main(container, outline) {
      // Checks if the browser is supported
      if (!mxClient.isBrowserSupported()) {
        // Displays an error message if the browser is not supported.
        mxUtils.error("Browser is not supported!", 200, false);
      } else {
        //Initializing global settings
        mxGraphHandler.prototype.guidesEnabled = true;
        mxGraphHandler.prototype.useGuidesForEvent = function (me) {
          return !mxEvent.isAltDown(me.getEvent());
        };
        mxConstants.GUIDE_COLOR = "#FF0000";
        mxConstants.GUIDE_STROKEWIDTH = 1;
        mxConstants.WORD_WRAP = "break-word";
        mxConstants.SHADOW_OFFSET_X = 5;
        mxConstants.SHADOW_OFFSET_Y = 5;
        mxConstants.SHADOW_OPACITY = 0.2;
        mxConstants.EDGE_SELECTION_COLOR = "#ddd";
        mxConstants.VERTEX_SELECTION_COLOR = "#000000";
        mxConstants.VERTEX_SELECTION_STROKEWIDTH = 2;
        mxConstants.EDGE_SELECTION_STROKEWIDTH = 2;
        mxEdgeHandler.prototype.snapToTerminals = true;
        mxConnectionHandler.prototype.movePreviewAway = false;
        mxClient.NO_FO = mxClient.NO_FO || mxClient.IS_SF || mxClient.IS_GC;
        graph = new mxGraph(container);
        graph.setPanning(true);
        graph.setTooltips(false);
        graph.htmlLabels = true;
        graph.setConnectable(true);
        graph.setAllowDanglingEdges(false);
        graph.centerZoom = false;
        graph.setMultigraph(false);
        graph.dropEnabled = true;
        graph.constrainChildren =
          false; // this won't let the the blocks inside the groups to not change size when groups are resized
        //graph.connectableEdges = false;
        var vStyle = graph.getStylesheet().getDefaultVertexStyle();
        var eStyle = graph.getStylesheet().getDefaultEdgeStyle();
        vStyle["shadow"] = false;
        vStyle["whiteSpace"] = "wrap";
        vStyle["arcSize"] = 0;
        vStyle["absoluteArcSize"] = 1;
        vStyle["rounded"] = 1;
        eStyle["edgeStyle"] = "orthogonalEdgeStyle";
        eStyle["strokeWidth"] = 4;
        eStyle["fontSize"] = 15;
        eStyle["targetJettySize"] = 25;
        eStyle["shadow"] = false;
        //eStyle["startArrow"]="oval";

        //Block properties editor
        graph
          .getSelectionModel()
          .addListener(mxEvent.CHANGE, function (sender, evt) {
            selectionChanged();
          });
        //Change floding and unfolding icons
        graph.collapsedImage = new mxImage("images/plus.svg", 10, 10);
        graph.expandedImage = new mxImage("images/minus.svg", 10, 10);
        //set valid drop targets
        var isValidDropTargetDefault = mxGraph.prototype.isValidDropTarget;
        mxGraph.prototype.isValidDropTarget = function (cell, cells, evt) {
          var defaultRetValue = isValidDropTargetDefault.apply(
            this,
            arguments
          );
          if (defaultRetValue) {
            if (cell.getStyle() === "group") return true;
            else if (graph.getCellStyle(cell)["shape"] === "swimlane")
              return true;
            else return false;
          } else return defaultRetValue;
        };
        // Matches DnD inside the graph
        mxDragSource.prototype.getDropTarget = function (graph, x, y) {
          var cell = graph.getCellAt(x, y);

          if (!graph.isValidDropTarget(cell)) {
            cell = null;
          }
          return cell;
        };
        // Creates rubberband selection
        var rubberband = new mxRubberband(graph);
        var keyHandler = new mxKeyHandler(graph);
        var parent = graph.getDefaultParent();
        outln = new mxOutline(graph, outline);
        /*graph.autoSizeCellsOnAdd = true;
				graph.autoSizeCells = true;/**/
        //Adjust vertices when new group is formed
        var graphCreateGroupCell = graph.createGroupCell;
        graph.createGroupCell = function (cells) {
          var group = graphCreateGroupCell.apply(this, arguments);
          var style = new Object();
          style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_SWIMLANE;
          style.startSize = 25;
          style.strokeWidth = 2;
          style.arcSize = 0;
          graph.getStylesheet().putCellStyle("group", style);
          group.setStyle("group");
          group.setValue("Sub model");
          return group;
        };

        //Undo/redo activities
        undoManager = new mxUndoManager();
        var listener = function (sender, evt) {
          undoManager.undoableEditHappened(evt.getProperty("edit"));
        };
        graph.getModel().addListener(mxEvent.UNDO, listener);
        graph.getView().addListener(mxEvent.UNDO, listener);
        // Helper method to mark parts with constituent=1 in the style
        graph.isPart = function (cell) {
          //original code
          /*var state = this.view.getState(cell);
					var style = (state != null) ? state.style : this.getCellStyle(cell);*/
          //new code
          var style = graph.getCellStyle(cell);

          return style["constituent"] == "1";
        };
        // Redirects selection to parent
        graph.selectCellForEvent = function (cell) {
          if (this.isPart(cell)) {
            cell = this.model.getParent(cell);
          }

          mxGraph.prototype.selectCellForEvent.apply(this, arguments);
        };
        //Copy Paste of blocks
        graph.cloneCells = function (
          cells,
          allowInvalidEdges,
          mapping,
          keepPosition
        ) {
          customValidationError = false;
          var out = mxGraph.prototype.cloneCells.apply(this, arguments);
          customValidationError = true;
          return out;
        };
        mxClipboard.cellsToString = function (cells) {
          var codec = new mxCodec();
          var model = new mxGraphModel();
          var parent = model.getChildAt(model.getRoot(), 0);
          for (var i = 0; i < cells.length; i++) {
            cells[i].setValue(JSON.stringify2(cells[i].getValue()));
            model.add(parent, cells[i]);
          }
          return mxUtils.getXml(codec.encode(model));
        };
        var textInput = document.createElement("textarea");
        mxUtils.setOpacity(textInput, 0);
        textInput.style.width = "1px";
        textInput.style.height = "1px";
        var restoreFocus = false;
        var gs = graph.gridSize;
        var lastPaste = null;
        var dx = 0;
        var dy = 0;
        textInput.value = " ";
        mxEvent.addListener(document, "keydown", function (evt) {
          var source = mxEvent.getSource(evt);
          if (
            graph.isEnabled() &&
            !graph.isMouseDown &&
            !graph.isEditing() &&
            source.nodeName != "INPUT"
          ) {
            if (
              evt.keyCode == 224 ||
              (!mxClient.IS_MAC && evt.keyCode == 17) ||
              (mxClient.IS_MAC && evt.keyCode == 91)
            ) {
              if (!restoreFocus) {
                textInput.style.position = "absolute";
                textInput.style.left = graph.container.scrollLeft + 10 + "px";
                textInput.style.top = graph.container.scrollTop + 10 + "px";
                graph.container.appendChild(textInput);
                restoreFocus = true;
                textInput.focus();
                textInput.select();
              }
            }
          }
        });
        mxEvent.addListener(document, "keyup", function (evt) {
          if (
            restoreFocus &&
            (evt.keyCode == 224 || evt.keyCode == 17 || evt.keyCode == 91)
          ) {
            restoreFocus = false;
            if (!graph.isEditing()) {
              graph.container.focus();
            }
            textInput.parentNode.removeChild(textInput);
          }
        });
        var copyCells = function (graph, cells) {
          if (cells.length > 0) {
            var clones = graph.cloneCells(cells);
            for (var i = 0; i < clones.length; i++) {
              var state = graph.view.getState(cells[i]);
              if (state != null) {
                var geo = graph.getCellGeometry(clones[i]);
                if (geo != null && geo.relative) {
                  geo.relative = false;
                  geo.x = state.x / state.view.scale - state.view.translate.x;
                  geo.y = state.y / state.view.scale - state.view.translate.y;
                }
              }
            }
            textInput.value = mxClipboard.cellsToString(clones);
          }
          textInput.select();
          lastPaste = textInput.value;
        };
        mxEvent.addListener(
          textInput,
          "copy",
          mxUtils.bind(this, function (evt) {
            if (graph.isEnabled() && !graph.isSelectionEmpty()) {
              copyCells(
                graph,
                mxUtils.sortCells(
                  graph.model.getTopmostCells(graph.getSelectionCells())
                )
              );
              dx = 0;
              dy = 0;
            }
          })
        );
        mxEvent.addListener(
          textInput,
          "cut",
          mxUtils.bind(this, function (evt) {
            if (graph.isEnabled() && !graph.isSelectionEmpty()) {
              copyCells(graph, graph.removeCells());
              dx = -gs;
              dy = -gs;
            }
          })
        );
        var importXml = function (xml, dx, dy) {
          dx = dx != null ? dx : 0;
          dy = dy != null ? dy : 0;
          var cells = [];
          try {
            var doc = mxUtils.parseXml(xml);
            var node = doc.documentElement;
            if (node != null) {
              var model = new mxGraphModel();
              var codec = new mxCodec(node.ownerDocument);
              codec.decode(node, model);
              var childCount = model.getChildCount(model.getRoot());
              var targetChildCount = graph.model.getChildCount(
                graph.model.getRoot()
              );
              graph.model.beginUpdate();
              try {
                for (var i = 0; i < childCount; i++) {
                  var parent = model.getChildAt(model.getRoot(), i);
                  if (targetChildCount > i) {
                    var target =
                      childCount == 1 ?
                      graph.getDefaultParent() :
                      graph.model.getChildAt(graph.model.getRoot(), i);
                    if (!graph.isCellLocked(target)) {
                      var children = model.getChildren(parent);
                      cells = cells.concat(
                        graph.importCells(children, dx, dy, target)
                      );
                    }
                  } else {
                    parent = graph.importCells(
                      [parent],
                      0,
                      0,
                      graph.model.getRoot()
                    )[0];
                    var children = graph.model.getChildren(parent);
                    graph.moveCells(children, dx, dy);
                    cells = cells.concat(children);
                  }
                }

                for (var i = 0; i < cells.length; i++) {
                  try {
                    cells[i].setValue(JSON.parse2(cells[i].getValue()));
                  } catch (e) {}
                }
              } finally {
                graph.model.endUpdate();
              }
            }
          } catch (e) {
            //alert(e);
            throw e;
          }
          return cells;
        };
        var pasteText = function (text) {
          var xml = mxUtils.trim(text);
          var x =
            graph.container.scrollLeft / graph.view.scale -
            graph.view.translate.x;
          var y =
            graph.container.scrollTop / graph.view.scale -
            graph.view.translate.y;
          if (xml.length > 0) {
            if (lastPaste != xml) {
              lastPaste = xml;
              dx = 0;
              dy = 0;
            } else {
              dx += gs;
              dy += gs;
            }
            if (xml.substring(0, 14) == "<mxGraphModel>") {
              graph.setSelectionCells(importXml(xml, dx, dy));
              graph.scrollCellToVisible(graph.getSelectionCell());
            }
          }
        };
        var extractGraphModelFromEvent = function (evt) {
          var data = null;
          if (evt != null) {
            var provider =
              evt.dataTransfer != null ? evt.dataTransfer : evt.clipboardData;
            if (provider != null) {
              if (
                document.documentMode == 10 ||
                document.documentMode == 11
              ) {
                data = provider.getData("Text");
              } else {
                data =
                  mxUtils.indexOf(provider.types, "text/html") >= 0 ?
                  provider.getData("text/html") :
                  null;
                if (
                  mxUtils.indexOf(
                    provider.types,
                    "text/plain" && (data == null || data.length == 0)
                  )
                ) {
                  data = provider.getData("text/plain");
                }
              }
            }
          }
          return data;
        };
        mxEvent.addListener(textInput, "paste", function (evt) {
          textInput.value = "";
          if (graph.isEnabled()) {
            var xml = extractGraphModelFromEvent(evt);
            if (xml != null && xml.length > 0) {
              pasteText(xml);
            } else {
              window.setTimeout(
                mxUtils.bind(this, function () {
                  pasteText(textInput.value);
                }),
                0
              );
            }
          }
          textInput.select();
        });
        //Delete blocks
        keyHandler.bindKey(46, function (evt) {
          if (graph.isEnabled()) graph.removeCells();
        });
        //undo and redo
        keyHandler.bindControlKey(90, function (evt) {
          if (graph.isEnabled()) {
            undoManager.undo();
          }
        });
        keyHandler.bindControlShiftKey(90, function (evt) {
          if (graph.isEnabled()) {
            undoManager.redo();
          }
        });
        //Toggle Blocks drawer
        keyHandler.bindControlKey(66, function (evt) {
          toggleSideBar("libraryOfBlocks");
        });
        //Toggle Editor drawer
        keyHandler.bindControlKey(69, function (evt) {
          toggleSideBar("editorForParameters");
        });
        //Toggle Printer drawer
        keyHandler.bindControlKey(80, function (evt) {
          toggleSideBar("printingTheModel");
        });
        //Toggle Zoom
        keyHandler.bindControlKey(107, function (evt) {
          graph.zoomIn();
        });
        keyHandler.bindControlKey(187, function (evt) {
          graph.zoomIn();
        });
        keyHandler.bindControlKey(109, function (evt) {
          graph.zoomOut();
        });
        keyHandler.bindControlKey(189, function (evt) {
          graph.zoomOut();
        });
        keyHandler.bindControlKey(96, function (evt) {
          graph.zoomActual();
        });
        keyHandler.bindControlKey(48, function (evt) {
          graph.zoomActual();
        });
        keyHandler.bindControlKey(97, function (evt) {
          graph.fit();
        });
        keyHandler.bindControlKey(49, function (evt) {
          graph.fit();
        });
        //Group and ungroup
        keyHandler.bindControlKey(71, function (evt) {
          if (graph.isEnabled()) {
            createSubModel();
          }
        });
        keyHandler.bindControlShiftKey(71, function (evt) {
          if (graph.isEnabled()) {
            ungroupSubModel();
          }
        });

        //Minimize and maximize
        keyHandler.bindControlKey(77, function (evt) {
          foldItems();
        });
        keyHandler.bindControlShiftKey(77, function (evt) {
          foldItems(false);
        });

        // To detect if touch events are actually supported, the following condition is recommended:
        // mxClient.IS_TOUCH || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0

        // Disables built-in text selection and context menu while not editing text
        var textEditing = mxUtils.bind(this, function (evt) {
          return graph.isEditing();
        });

        container.onselectstart = textEditing;
        container.onmousedown = textEditing;

        if (
          mxClient.IS_IE &&
          (typeof document.documentMode === "undefined" ||
            document.documentMode < 9)
        ) {
          mxEvent.addListener(container, "contextmenu", textEditing);
        } else {
          container.oncontextmenu = textEditing;
        }

        graph.popupMenuHandler.autoExpand = true;

        graph.popupMenuHandler.isSelectOnPopup = function (me) {
          return mxEvent.isMouseEvent(me.getEvent());
        };

        // Installs context menu
        graph.popupMenuHandler.factoryMethod = function (menu, cell, evt) {
          menu.addItem("Item 1", null, function () {
            alert("Item 1");
          });

          menu.addSeparator();

          var submenu1 = menu.addItem("Submenu 1", null, null);

          menu.addItem(
            "Subitem 1",
            null,
            function () {
              alert("Subitem 1");
            },
            submenu1
          );
          menu.addItem(
            "Subitem 1",
            null,
            function () {
              alert("Subitem 2");
            },
            submenu1
          );
        };

        // Context menu trigger implementation depending on current selection state
        // combined with support for normal popup trigger.
        var cellSelected = false;
        var selectionEmpty = false;
        var menuShowing = false;

        graph.fireMouseEvent = function (evtName, me, sender) {
          if (evtName == mxEvent.MOUSE_DOWN) {
            // For hit detection on edges
            me = this.updateMouseEvent(me);

            cellSelected = this.isCellSelected(me.getCell());
            selectionEmpty = this.isSelectionEmpty();
            menuShowing = graph.popupMenuHandler.isMenuShowing();
          }

          mxGraph.prototype.fireMouseEvent.apply(this, arguments);
        };

        // Shows popup menu if cell was selected or selection was empty and background was clicked
        graph.popupMenuHandler.mouseUp = function (sender, me) {
          this.popupTrigger = !graph.isEditing() &&
            (this.popupTrigger ||
              (!menuShowing &&
                !graph.isEditing() &&
                !mxEvent.isMouseEvent(me.getEvent()) &&
                ((selectionEmpty &&
                    me.getCell() == null &&
                    graph.isSelectionEmpty()) ||
                  (cellSelected && graph.isCellSelected(me.getCell())))));
          mxPopupMenuHandler.prototype.mouseUp.apply(this, arguments);
        };
        /*// Adds mouse wheel handling for zoom
				mxEvent.addMouseWheelListener(function (evt, up) {
					if (up) {
						graph.zoomIn();
					} else {
						graph.zoomOut();
					}
					mxEvent.consume(evt);
				});*/

        // Tap and hold on background starts rubberband for multiple selected
        // cells the cell associated with the event is deselected
        graph.addListener(mxEvent.TAP_AND_HOLD, function (sender, evt) {
          if (!mxEvent.isMultiTouchEvent(evt)) {
            var me = evt.getProperty("event");
            var cell = evt.getProperty("cell");

            if (cell == null) {
              var pt = mxUtils.convertPoint(
                this.container,
                mxEvent.getClientX(me),
                mxEvent.getClientY(me)
              );
              rubberband.start(pt.x, pt.y);
            } else if (
              graph.getSelectionCount() > 1 &&
              graph.isCellSelected(cell)
            ) {
              graph.removeSelectionCell(cell);
            }

            // Blocks further processing of the event
            evt.consume();
          }
        });

        // Adds custom hit detection if native hit detection found no cell
        graph.updateMouseEvent = function (me) {
          var me = mxGraph.prototype.updateMouseEvent.apply(this, arguments);
          if (me.getState() == null) {
            var cell = this.getCellAt(me.graphX, me.graphY);
            if (
              cell != null &&
              this.isSwimlane(cell) &&
              this.hitsSwimlaneContent(cell, me.graphX, me.graphY)
            ) {
              cell = null;
            } else {
              me.state = this.view.getState(cell);

              if (me.state != null && me.state.shape != null) {
                this.container.style.cursor =
                  me.state.shape.node.style.cursor;
              }
            }
          }

          if (me.getState() == null) {
            this.container.style.cursor = "default";
          }

          return me;
        };

        //Lines before connecting edges
        graph.view.updateFixedTerminalPoint = function (
          edge,
          terminal,
          source,
          constraint
        ) {
          mxGraphView.prototype.updateFixedTerminalPoint.apply(
            this,
            arguments
          );
          var pts = edge.absolutePoints;
          var pt = pts[source ? 0 : pts.length - 1];
          if (
            terminal != null &&
            pt == null &&
            this.getPerimeterFunction(terminal) == null
          ) {
            edge.setAbsoluteTerminalPoint(
              new mxPoint(
                this.getRoutingCenterX(terminal),
                this.getRoutingCenterY(terminal)
              ),
              source
            );
          }
        };
        graph.connectionHandler.createEdgeState = function (me) {
          var edge = graph.createEdge(null, null, null, null, null);
          return new mxCellState(
            this.graph.view,
            edge,
            this.graph.getCellStyle(edge)
          );
        };
        //Custom Grid
        (function () {
          try {
            var canvas = document.createElement("canvas");
            canvas.style.position = "absolute";
            canvas.style.top = "0px";
            canvas.style.left = "0px";
            canvas.style.zIndex = -1;
            graph.container.appendChild(canvas);
            var ctx = canvas.getContext("2d");
            var mxGraphViewIsContainerEvent =
              mxGraphView.prototype.isContainerEvent;
            mxGraphView.prototype.isContainerEvent = function (evt) {
              return (
                mxGraphViewIsContainerEvent.apply(this, arguments) ||
                mxEvent.getSource(evt) == canvas
              );
            };
            var s = 0;
            var gs = 0;
            var tr = new mxPoint();
            var w = 0;
            var h = 0;
            repaintGrid();

            function repaintGrid() {
              if (ctx != null) {
                var bounds = graph.getGraphBounds();
                var width = Math.max(
                  bounds.x + bounds.width,
                  graph.container.clientWidth
                );
                var height = Math.max(
                  bounds.y + bounds.height,
                  graph.container.clientHeight
                );
                var sizeChanged = width != w || height != h;
                if (
                  graph.view.scale != s ||
                  graph.view.translate.x != tr.x ||
                  graph.view.translate.y != tr.y ||
                  gs != graph.gridSize ||
                  sizeChanged
                ) {
                  tr = graph.view.translate.clone();
                  s = graph.view.scale;
                  gs = graph.gridSize;
                  w = width;
                  h = height;
                  if (!sizeChanged) {
                    ctx.clearRect(0, 0, w, h);
                  } else {
                    canvas.setAttribute("width", w);
                    canvas.setAttribute("height", h);
                  }
                  var tx = tr.x * s;
                  var ty = tr.y * s;
                  var minStepping = graph.gridSize;
                  var stepping = minStepping * s;
                  if (stepping < minStepping) {
                    var count =
                      Math.round(Math.ceil(minStepping / stepping) / 2) * 2;
                    stepping = count * stepping;
                  }
                  var xs = Math.floor((0 - tx) / stepping) * stepping + tx;
                  var xe = Math.ceil(w / stepping) * stepping;
                  var ys = Math.floor((0 - ty) / stepping) * stepping + ty;
                  var ye = Math.ceil(h / stepping) * stepping;
                  xe += Math.ceil(stepping);
                  ye += Math.ceil(stepping);
                  var ixs = Math.round(xs);
                  var ixe = Math.round(xe);
                  var iys = Math.round(ys);
                  var iye = Math.round(ye);
                  ctx.strokeStyle = "#f0f0f0";
                  ctx.fillStyle = "#ffffff";
                  ctx.fillRect(0, 0, canvas.width, canvas.height);
                  ctx.beginPath();
                  ctx.lineWidth = 0.5;
                  for (var x = xs; x <= xe; x += stepping) {
                    x = Math.round((x - tx) / stepping) * stepping + tx;
                    var ix = Math.round(x);
                    ctx.moveTo(ix + 0.5, iys + 0.5);
                    ctx.lineTo(ix + 0.5, iye + 0.5);
                  }
                  for (var y = ys; y <= ye; y += stepping) {
                    y = Math.round((y - ty) / stepping) * stepping + ty;
                    var iy = Math.round(y);
                    ctx.moveTo(ixs + 0.5, iy + 0.5);
                    ctx.lineTo(ixe + 0.5, iy + 0.5);
                  }
                  ctx.closePath();
                  ctx.stroke();
                  ctx.beginPath();
                  ctx.lineWidth = 1;
                  for (var x = xs; x <= xe; x += 5 * stepping) {
                    x = Math.round((x - tx) / stepping) * stepping + tx;
                    var ix = Math.round(x);
                    ctx.moveTo(ix + 0.5, iys + 0.5);
                    ctx.lineTo(ix + 0.5, iye + 0.5);
                  }
                  for (var y = ys; y <= ye; y += 5 * stepping) {
                    y = Math.round((y - ty) / stepping) * stepping + ty;
                    var iy = Math.round(y);
                    ctx.moveTo(ixs + 0.5, iy + 0.5);
                    ctx.lineTo(ixe + 0.5, iy + 0.5);
                  }
                  ctx.closePath();
                  ctx.stroke();
                  ctx.beginPath();
                  ctx.lineWidth = 1.5;
                  for (var x = xs; x <= xe; x += 10 * stepping) {
                    x = Math.round((x - tx) / stepping) * stepping + tx;
                    var ix = Math.round(x);
                    ctx.moveTo(ix + 0.5, iys + 0.5);
                    ctx.lineTo(ix + 0.5, iye + 0.5);
                  }
                  for (var y = ys; y <= ye; y += 10 * stepping) {
                    y = Math.round((y - ty) / stepping) * stepping + ty;
                    var iy = Math.round(y);
                    ctx.moveTo(ixs + 0.5, iy + 0.5);
                    ctx.lineTo(ixe + 0.5, iy + 0.5);
                  }
                  ctx.closePath();
                  ctx.stroke();
                }
              }
            }
          } catch (e) {
            /* mxLog.show();
             mxLog.debug("Using background image");*/
            container.style.backgroundImage = "url('/images/grid.gif')";
          }
          var mxGraphViewValidateBackground =
            mxGraphView.prototype.validateBackground;
          mxGraphView.prototype.validateBackground = function () {
            mxGraphViewValidateBackground.apply(this, arguments);
            try {
              repaintGrid();
            } catch (e) {}
            MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
          };
        })();
        //Connection switching source traget, when required
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (
          sender,
          evt
        ) {
          var edge = evt.getProperty("cell");
          var source = graph.getModel().getTerminal(edge, true);
          var target = graph.getModel().getTerminal(edge, false);
          if (source.geometry.x === 0 && target.geometry.x === 1) {
            graph.getModel().setTerminal(edge, source, false);
            graph.getModel().setTerminal(edge, target, true);
          }
        });
        //Connection validation
        var customValidationError = true;
        var default_getEdgeValidationError =
          mxGraph.prototype.getEdgeValidationError;
        mxGraph.prototype.getEdgeValidationError = function (
          edge,
          source,
          target
        ) {
          //console.log(source.edges);
          var defaultOut = default_getEdgeValidationError.apply(
            this,
            arguments
          );
          if (customValidationError) {
            var outError;
            if (source.parent === target.parent)
              outError = "Cannot connect to the same block.";
            if (source.geometry.x === 0 && target.geometry.x === 0)
              outError = "Cannot connect both the inputs.";
            if (source.geometry.x === 1 && target.geometry.x === 1)
              outError = "Cannot connect both the outputs.";
            if (
              (target.geometry.x == 0 && target.getEdgeCount() > 0) ||
              (source.geometry.x == 0 && source.getEdgeCount() > 0)
            )
              outError = "Only one input is allowed per port.";
            return outError || defaultOut;
          } else return defaultOut;
        };
        mxGraph.prototype.validationAlert = function (message) {
          notyf.error(message);
        };

        //Dynamic Edge coloring
        var defaultModelStyle = graph.model.getStyle;
        graph.model.getStyle = function (cell) {
          var style = defaultModelStyle.apply(this, arguments);
          if (cell != null) {
            if (this.isEdge(cell)) {
              var target = this.getTerminal(cell, true);
              if (target != null) {
                var state = graph.getView().getState(target);
                var targetStyle =
                  state != null ? state.style : graph.getCellStyle(target);
                var fill = mxUtils.getValue(
                  targetStyle,
                  mxConstants.STYLE_FILLCOLOR
                );
                if (fill != null) {
                  style += ";strokeColor=" + fill;
                }
              }
            }
          }
          return style;
        };

        //selection of a vertix
        mxGraph.prototype.isCellSelectable = function (cell) {
          var state = this.view.getState(cell);
          var style = state != null ? state.style : this.getCellStyle(cell);

          return (
            this.isCellsSelectable() &&
            !this.isCellLocked(cell) &&
            style["selectable"] != 0
          );
        };

        //How Label is handled for a model
        graph.getLabel = function (cell) {
          //console.log(cell);
          if (!!cell.value) {
            if (typeof cell.value === "object") {
              try {
                eval(
                  "var tempModel = new umk_" +
                  cell.value.bid +
                  " (cell.value);"
                );
                return (
                  tempModel.Name +
                  "<p class='block-margin'>" +
                  tempModel.Details() +
                  "</p>" || ""
                );
              } catch (e) {
                pullDBAndGenModel(cell.value.bid)
                  .then(function () {
                    eval(
                      "var tempModel = new umk_" +
                      cell.value.bid +
                      " (cell.value);"
                    );
                    console.log(tempModel);
                    graph.cellLabelChanged(
                      cell,
                      tempModel.Name +
                      "<p class='block-margin'>" +
                      tempModel.Details() +
                      "</p>"
                    );
                  })
                  .catch(function (e) {
                    console.log(e);
                    notyf.error("Error in loading the block");
                  });
                return "Loading...";
              }
            } else return cell.value;
          } else return null;
        };
        graph.getEditingValue = function (cell, evt) {
          if (!!cell.value) {
            if (typeof cell.value === "object") return cell.value.Name || "";
            else return cell.value;
          } else return null;
        };
        graph.labelChanged = function (cell, newValue, trigger) {
          if (!!cell.value) {
            if (typeof cell.value === "object") {
              var value = mxUtils.clone(cell.value);
              value.Name = newValue;
              newValue = value;
            }
          }
          mxGraph.prototype.labelChanged.apply(this, arguments);
        };

        // Adds cells to the model in a single step
        graph.getModel().beginUpdate();
        try {
          /*var v1 = graph.insertVertex(parent, null, 'H<b>e</b>llo,', 20, 20, 80, 30);
					var v2 = graph.insertVertex(parent, null, 'World!', 200, 150, 80, 30);
					var e1 = graph.insertEdge(parent, null, '', v1, v2);
					var v1 = graph.insertVertex(parent, null, 'A', 20, 20, 100, 40);
					var v1 = graph.insertVertex(parent, null, 'A', 20, 20, 100, 40);*/
        } finally {
          // Updates the display
          graph.getModel().endUpdate();
        }
      }
    }

    function insertVertex(v1, umkModel, x, y, evt, cell) {
      var parent = graph.getDefaultParent();
      var model = graph.getModel();
      model.beginUpdate();
      try {
        var newPt = {
          x: x,
          y: y
        };
        if (cell) {
          var pt = cell.getGeometry().getPoint();
          newPt.x -= pt.x;
          newPt.y -= pt.y;
        }
        v1 = graph.insertVertex(
          cell,
          null,
          umkModel,
          newPt.x,
          newPt.y,
          200,
          100,
          "fillColor=" +
          umkModel.Colors.bg +
          ";fontColor=" +
          umkModel.Colors.fg +
          ";verticalAlign=top;strokeColor=" +
          umkModel.Colors.bg +
          ";"
        );
        var tempDetails = umkModel.Details();

        v1.setConnectable(false);
        v1.geometry.alternateBounds = new mxRectangle(0, 0, 200, 20);
        for (var i = 1; i < umkModel.TerminalsIn.value + 1; i++) {
          var p1 = graph.insertVertex(
            v1,
            null,
            "$u" +
            (umkModel.TerminalsIn.value > 1 ? "_{" + i + "}" : "") +
            "(t)$",
            0,
            i / (umkModel.TerminalsIn.value + 1),
            8,
            8,
            "constituent=1;fillColor=" +
            umkModel.Colors.bg +
            ";fontColor=" +
            umkModel.Colors.fg +
            ";strokeColor=" +
            umkModel.Colors.bg +
            ";labelPosition=right;labelWidth=80;align=left;shape=rectangle;portConstraint=west;shadow=0",
            true
          );
          p1.geometry.offset = new mxPoint(-8, -4);
        }
        for (var i = 1; i < umkModel.TerminalsOut.value + 1; i++) {
          var p2 = graph.insertVertex(
            v1,
            null,
            "$y" +
            (umkModel.TerminalsOut.max > 1 ? "_{" + i + "}" : "") +
            "(t)$",
            1,
            i / (umkModel.TerminalsOut.value + 1),
            8,
            16,
            "constituent=1;fillColor=" +
            umkModel.Colors.bg +
            ";fontColor=" +
            umkModel.Colors.fg +
            ";strokeColor=" +
            umkModel.Colors.bg +
            ";labelPosition=left;labelWidth=80;align=right;shape=triangle;portConstraint=east;shadow=0",
            true
          );
          p2.geometry.offset = new mxPoint(0, -8);
        }
        graph.setSelectionCell(v1);
        var EO = graph.insertVertex(
          v1,
          null,
          "",
          0.5,
          1,
          0,
          0,
          "constituent=1;align=center;verticalAlign=bottom;fillColor=" +
          umkModel.Colors.bg +
          ";fontColor=" +
          umkModel.Colors.fg +
          ";strokeColor=" +
          umkModel.Colors.bg +
          ";",
          true
        );
        EO.geometry.offset = new mxPoint(0, 00);
        EO.setConnectable(false);
      } finally {
        model.endUpdate();
      }
    }

    function addANewDraggableIcon(sidebar, data) {
      var addVertices = function (graph, evt, cell, x, y) {
        try {
          eval("var umkModel = new umk_" + data.key + "();");
          //console.log(data);
          umkModel.Constructor({});
          insertVertex(v1, umkModel, x, y, evt, cell);
        } catch (e) {
          console.log(e);
          graph.removeCells([v1]);
          notyf.error(
            "Error in the mathematical model. If your internet connection is good, please contact the support."
          );
        }
        graph.setSelectionCell(v1);
      };
      var finishDragAct = function (graph, evt, cell, x, y) {
        pullDBAndGenModel(data.key)
          .then(function () {
            addVertices(graph, evt, cell, x, y);
          })
          .catch(function () {
            notyf.error(
              "Unknown error: please contact support if it continues."
            );
          });
      };
      var v1;
      var img = document.createElement("img");
      /*blockDiv.innerHTML = "Name:"+data.name+"; Description:"+data.description;
			blockDiv.setAttribute('id', 'block_'+data.order+'for_'+data.key);*/
      var img = document.createElement("img");
      img.setAttribute(
        "src",
        svgTextToURL(getIconWith(data.colors, data.icon))
      );
      img.style.width = "64px";
      img.style.height = "64px";
      img.title =
        data.name +
        ": " +
        data.description +
        "\n\nDrag this to the diagram to create a new vertex";
      sidebar.appendChild(img);

      var dragElt = document.createElement("div");
      dragElt.style.border = "dashed black 1px";
      dragElt.style.width = "200px";
      dragElt.style.height = "100px";
      var ds = mxUtils.makeDraggable(
        img,
        graph,
        finishDragAct,
        dragElt,
        0,
        0,
        true,
        true
      );
      ds.setGuidesEnabled(true);
    }

    // Touch screen
    (function () {
      // Enables rotation handle
      mxVertexHandler.prototype.rotationEnabled = true;

      // Enables managing of sizers
      mxVertexHandler.prototype.manageSizers = true;

      // Enables live preview
      mxVertexHandler.prototype.livePreview = true;

      // Sets constants for touch style
      mxConstants.HANDLE_SIZE = 16;
      mxConstants.LABEL_HANDLE_SIZE = 7;

      // Larger tolerance and grid for real touch devices
      if (
        mxClient.IS_TOUCH ||
        navigator.maxTouchPoints > 0 ||
        navigator.msMaxTouchPoints > 0
      ) {
        mxShape.prototype.svgStrokeTolerance = 18;
        mxVertexHandler.prototype.tolerance = 12;
        mxEdgeHandler.prototype.tolerance = 12;
        mxGraph.prototype.tolerance = 12;
      }

      // One finger pans (no rubberband selection) must start regardless of mouse button
      mxPanningHandler.prototype.isPanningTrigger = function (me) {
        var evt = me.getEvent();

        return (
          (me.getState() == null && !mxEvent.isMouseEvent(evt)) ||
          (mxEvent.isPopupTrigger(evt) &&
            (me.getState() == null ||
              mxEvent.isControlDown(evt) ||
              mxEvent.isShiftDown(evt)))
        );
      };

      // Don't clear selection if multiple cells selected
      var graphHandlerMouseDown = mxGraphHandler.prototype.mouseDown;
      mxGraphHandler.prototype.mouseDown = function (sender, me) {
        graphHandlerMouseDown.apply(this, arguments);

        if (
          this.graph.isCellSelected(me.getCell()) &&
          this.graph.getSelectionCount() > 1
        ) {
          this.delayedSelection = false;
        }
      };

      // On connect the target is selected and we clone the cell of the preview edge for insert
      mxConnectionHandler.prototype.selectCells = function (edge, target) {
        if (target != null) {
          this.graph.setSelectionCell(target);
        } else {
          this.graph.setSelectionCell(edge);
        }
      };

      // Overrides double click handling to use the tolerance
      var graphDblClick = mxGraph.prototype.dblClick;
      mxGraph.prototype.dblClick = function (evt, cell) {
        if (cell == null) {
          var pt = mxUtils.convertPoint(
            this.container,
            mxEvent.getClientX(evt),
            mxEvent.getClientY(evt)
          );
          cell = this.getCellAt(pt.x, pt.y);
        }

        graphDblClick.call(this, evt, cell);
      };

      // Rounded edge and vertex handles
      var touchHandle = new mxImage("images/handle-main.png", 17, 17);
      mxVertexHandler.prototype.handleImage = touchHandle;
      mxEdgeHandler.prototype.handleImage = touchHandle;
      mxOutline.prototype.sizerImage = touchHandle;

      mxVertexHandler.prototype.rotationHandleVSpacing = -30;
      // Pre-fetches touch handle
      new Image().src = touchHandle.src;

      // Adds connect icon to selected vertex
      var connectorSrc = "images/handle-connect.png";

      var vertexHandlerInit = mxVertexHandler.prototype.init;
      mxVertexHandler.prototype.init = function () {
        // TODO: Use 4 sizers, move outside of shape
        //this.singleSizer = this.state.width < 30 && this.state.height < 30;
        vertexHandlerInit.apply(this, arguments);

        // Only show connector image on one cell and do not show on containers
        if (
          this.graph.connectionHandler.isEnabled() &&
          this.graph.isCellConnectable(this.state.cell) &&
          this.graph.getSelectionCount() == 1
        ) {
          this.connectorImg = mxUtils.createImage(connectorSrc);
          this.connectorImg.style.cursor = "pointer";
          this.connectorImg.style.width = "29px";
          this.connectorImg.style.height = "29px";
          this.connectorImg.style.position = "absolute";

          if (!mxClient.IS_TOUCH) {
            this.connectorImg.setAttribute(
              "title",
              mxResources.get("connect")
            );
            mxEvent.redirectMouseEvents(
              this.connectorImg,
              this.graph,
              this.state
            );
          }

          // Starts connecting on touch/mouse down
          mxEvent.addGestureListeners(
            this.connectorImg,
            mxUtils.bind(this, function (evt) {
              this.graph.popupMenuHandler.hideMenu();
              this.graph.stopEditing(false);

              var pt = mxUtils.convertPoint(
                this.graph.container,
                mxEvent.getClientX(evt),
                mxEvent.getClientY(evt)
              );
              this.graph.connectionHandler.start(this.state, pt.x, pt.y);
              this.graph.isMouseDown = true;
              this.graph.isMouseTrigger = mxEvent.isMouseEvent(evt);
              mxEvent.consume(evt);
            })
          );

          this.graph.container.appendChild(this.connectorImg);
        }

        this.redrawHandles();
      };

      var vertexHandlerHideSizers = mxVertexHandler.prototype.hideSizers;
      mxVertexHandler.prototype.hideSizers = function () {
        vertexHandlerHideSizers.apply(this, arguments);

        if (this.connectorImg != null) {
          this.connectorImg.style.visibility = "hidden";
        }
      };

      var vertexHandlerReset = mxVertexHandler.prototype.reset;
      mxVertexHandler.prototype.reset = function () {
        vertexHandlerReset.apply(this, arguments);

        if (this.connectorImg != null) {
          this.connectorImg.style.visibility = "";
        }
      };

      var vertexHandlerRedrawHandles =
        mxVertexHandler.prototype.redrawHandles;
      mxVertexHandler.prototype.redrawHandles = function () {
        vertexHandlerRedrawHandles.apply(this);

        if (this.state != null && this.connectorImg != null) {
          var pt = new mxPoint();
          var s = this.state;

          // Top right for single-sizer
          if (mxVertexHandler.prototype.singleSizer) {
            pt.x = s.x + s.width - this.connectorImg.offsetWidth / 2;
            pt.y = s.y - this.connectorImg.offsetHeight / 2;
          } else {
            pt.x =
              s.x +
              s.width +
              mxConstants.HANDLE_SIZE / 2 +
              4 +
              this.connectorImg.offsetWidth / 2;
            pt.y = s.y + s.height / 2;
          }

          var alpha = mxUtils.toRadians(
            mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION, 0)
          );

          if (alpha != 0) {
            var cos = Math.cos(alpha);
            var sin = Math.sin(alpha);

            var ct = new mxPoint(s.getCenterX(), s.getCenterY());
            pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
          }

          this.connectorImg.style.left =
            pt.x - this.connectorImg.offsetWidth / 2 + "px";
          this.connectorImg.style.top =
            pt.y - this.connectorImg.offsetHeight / 2 + "px";
        }
      };

      var vertexHandlerDestroy = mxVertexHandler.prototype.destroy;
      mxVertexHandler.prototype.destroy = function (sender, me) {
        vertexHandlerDestroy.apply(this, arguments);

        if (this.connectorImg != null) {
          this.connectorImg.parentNode.removeChild(this.connectorImg);
          this.connectorImg = null;
        }
      };

      // Pre-fetches touch connector
      new Image().src = connectorSrc;
    })();

    //Group blocks
    function createSubModel() {
      var model = graph.getModel();
      model.beginUpdate();
      try {
        var subModel = graph.groupCells(null, 10, graph.getSelectionCells());
        subModel.geometry.alternateBounds = new mxRectangle(0, 0, 200, 25);
        graph.setSelectionCell(subModel);
      } catch (e) {
        console.log(e);
        notyf.error("Unable to group the selected items");
      } finally {
        model.endUpdate();
      }
    }

    function ungroupSubModel() {
      var model = graph.getModel();
      model.beginUpdate();
      try {
        var cells = graph.getSelectionCells();
        for (var i = 0; i < cells.length; i++) {
          if (cells[i].getStyle() === "group") {
            var sCells = graph.getSelectionCells();
            sCells = sCells.concat(cells[i].children);
            //console.log(sCells);
            graph.ungroupCells([cells[i]]);
            graph.setSelectionCells(sCells);
          }
        }
      } catch (e) {
        console.log(e);
        notyf.error("Unable to un-group the selected items");
      } finally {
        model.endUpdate();
      }
    }
    // fold and unfold
    function foldItems(fold = true) {
      if (graph.getSelectionCells().length > 0) {
        graph.foldCells(fold, false, graph.getSelectionCells());
      } else graph.foldCells(fold, false, graph.getDefaultParent().children);
    }

    /*//pan the graph
    function panTheGraph(direction) {
      switch (direction) {
        case 0:
        graph.panGraph(graph.panDx, graph.panDy+10);
          break;
          case 1:
        graph.panGraph(graph.panDx, graph.panDy-10);
          break;
          case 2:
        graph.panGraph(graph.panDx-10, graph.panDy);
          break;
          case 3:
        graph.panGraph(graph.panDx+10, graph.panDy+10);
          break;
      }
      graph.refresh();
    }*/
  </script>

  <style>
    html,
    body {
      width: 100%;
      height: 100%;
    }

    #modelContainer {
      position: absolute;
      overflow: hidden;
      top: 36px;
      left: 0px;
      bottom: 18px;
      right: 0px;
      cursor: default;
    }

    .MJXc-display {
      margin: 0 !important;
    }

    .block-margin {
      margin: 0.5em 0 5em 0 !important;
    }

    .btnGreen,
    .btnGreen>div,
    .btnGreen>img,
    .btnGreen>i {
      color: rgba(80, 197, 56, 1);
      border-color: rgba(80, 197, 56, 1) !important;
    }

    .btnRed,
    .btnRed>div,
    .btnRed>img,
    .btnRed>i {
      color: #ff0000;
      border-color: #ff0000 !important;
    }

    .ToolBarButton>div,
    .ToolBarButton>img,
    .ToolBarButton>i {
      border-width: 2px !important;
      width: 30px;
      height: 30px;
    }

    .ToolBarButton {
      padding: 2px;
      font-size: 15px;
      -webkit-user-drag: none;
      -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
      width: 34px;
      height: 34px;
      border-radius: 17px;
      display: inline-block;
      cursor: pointer;
      position: fixed;
    }

    .btnGreen:hover {
      box-shadow: 0 0 3px 3px rgba(56, 207, 21, 0.3);
    }

    .btnGreen:active {
      box-shadow: 0 0 1px 3px rgba(56, 207, 21, 0.95);
    }

    .btnRed:hover {
      box-shadow: 0 0 3px 3px rgba(255, 00, 0, 0.3);
    }

    .btnRed:active {
      box-shadow: 0 0 1px 3px rgba(255, 00, 0, 0.95);
    }

    .rotateNote {
      -webkit-transform: rotate(90deg);
      -moz-transform: rotate(90deg);
      -o-transform: rotate(90deg);
      -ms-transform: rotate(90deg);
      transform: rotate(90deg);
    }
  </style>
</head>

<body>
  <div id="modelContainer" class="umk_main" style="transition: margin 700ms;"></div>
  <div id="toolBar" class="umk_main w3-bar w3-indigo w3-card w3-xlarge"
    style="transition: margin 700ms;position:fixed;top:0;left:0;">
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick=""
      title="Show menu (Ctrl+)&#10;Pull the menu drawer.">
      <i class="fa-fw fas fa-bars"></i>
    </div>
    <div class="w3-bar-item" style="padding: 0px;">
      <i class="fa-fw fas fa-ellipsis-v"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;"
      onclick="toggleSideBar('libraryOfBlocks')" title="Add Blocks (Ctrl+B)&#10;Displays or hides the blocks drawer">
      <i class="fa-fw fas fa-th-large"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;"
      onclick="toggleSideBar('editorForParameters')"
      title="Edit block (Ctrl+E)&#10;Displays or hides the editor drawer for blocks.">
      <i class="fa-fw far fa-edit"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;"
      onclick="if (graph.isEnabled()) graph.removeCells();" title="Delete (Del)&#10;Delete the selected blocks.">
      <i class="fa-fw fas fa-trash-alt"></i>
    </div>
    <div class="w3-bar-item" style="padding: 0px;">
      <i class="fa-fw fas fa-ellipsis-v"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;"
      onclick="toggleSideBar('printingTheModel')"
      title="Show all blocks (Ctrl+P)&#10;Displays or hides the printer drawer">
      <i class="fa-fw fas fa-print"></i>
    </div>
    <div class="w3-bar-item w3-button w3-red w3-hover-indigo" style="padding: 0px 4px;"
      onclick="toggleSideBar('printingTheModel')"
      title="Show all blocks (Ctrl+P)&#10;Displays or hides the printer drawer">
      <i class="fa-fw fas fa-cogs"></i>
    </div>
    <div class="w3-bar-item w3-button w3-red w3-hover-indigo" style="padding: 0px 4px;"
      onclick="toggleSideBar('printingTheModel')"
      title="Show all blocks (Ctrl+P)&#10;Displays or hides the printer drawer">
      <i class="fa-fw fas fa-sort-numeric-up"></i>
    </div>
    <div class="w3-bar-item w3-button w3-red w3-hover-indigo" style="padding: 0px 4px;"
      onclick="toggleSideBar('printingTheModel')"
      title="Show all blocks (Ctrl+P)&#10;Displays or hides the printer drawer">
      <i class="fa-fw fas fa-play"></i>
    </div>
    <div class="w3-bar-item" style="padding: 0px;">
      <i class="fa-fw fas fa-ellipsis-v"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="graph.zoomOut()"
      title="Zoom out (Ctrl+minus)&#10;Zooms out the block diagram">
      <i class="fa-fw fas fa-search-minus"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="graph.zoomIn()"
      title="Zoom in (Ctrl+plus)&#10;Zooms in the block diagram">
      <i class="fa-fw fas fa-search-plus"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="graph.zoomActual()"
      title="Zoom 1:1 (Ctrl+0)&#10;Zooms the block diagram to its original size">
      <i class="fa-fw fas fa-compress"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="graph.fit()"
      title="Fit all (Ctrl+1)&#10;Zooms the block diagram to fit the whole whole diagram">
      <i class="fa-fw fas fa-expand"></i>
    </div>
    <div class="w3-bar-item" style="padding: 0px;">
      <i class="fa-fw fas fa-ellipsis-v"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="undoManager.undo()"
      title="Undo (Ctrl+Z)&#10;Undo the recent changes">
      <i class="fa-fw fas fa-undo"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="undoManager.redo()"
      title="Redo (Ctrl+Shift+Z)&#10;Redo the recent changes">
      <i class="fa-fw fas fa-redo"></i>
    </div>
    <div class="w3-bar-item" style="padding: 0px;">
      <i class="fa-fw fas fa-ellipsis-v"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="createSubModel()"
      title="Group (Ctrl+G)&#10;Group the selected blocks to create a sub-model">
      <i class="fa-fw far fa-object-group"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="ungroupSubModel()"
      title="Ungroup (Ctrl+Shift+G)&#10;Ungroup the selected sub-models">
      <i class="fa-fw far fa-object-ungroup"></i>
    </div>
    <div class="w3-bar-item" style="padding: 0px;">
      <i class="fa-fw fas fa-ellipsis-v"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="foldItems()"
      title="Minimize (Ctrl+M)&#10;Minimize the selected blocks and sub-models">
      <i class="fa-fw fas fa-window-minimize"></i>
    </div>
    <div class="w3-bar-item w3-button w3-hover-indigo" style="padding: 0px 4px;" onclick="foldItems(false)"
      title="Maximize (Ctrl+Shift+M)&#10;Maximize the selected blocks and sub-models">
      <i class="fa-fw fas fa-window-maximize"></i>
    </div>
  </div>
  <div id="statusBar" class="umk_main w3-bar w3-dark-grey"
    style="transition: margin 700ms;position:fixed; bottom:0;right:0">
    <div class="w3-bar-item w3-right w3-small" style="padding: 0px;">
      Design mode
    </div>
    <div class="w3-bar-item w3-right w3-small" style="padding: 0px; margin: 0 8px;">
      <i class="fas fa-braille"></i>
    </div>
  </div>
  <div id="outlineContainer" class="w3-hide-small w3-hide-medium"
    style="position:fixed;overflow:hidden;top:50px;right:5px;width:200px;height:140px;background:transparent;border-style:solid;border-color:black;">
  </div>
  <div id="libraryOfBlocks" class="w3-sidebar w3-animate-left"
    style="z-index: 2; left: 0px; top: 0px; width: 25%;display: none;touch-action: none; border-right: solid 2px black;">
    <div class="w3-block w3-yellow w3-hover-red w3-button" onclick="toggleSideBar('libraryOfBlocks')">
      <div class="w3-right">
        <i class="fas fa-sign-out-alt fa-rotate-180"></i>
      </div>
      <div class="w3-left">
        Close
      </div>
    </div>
    <div id="blocksBar"></div>
  </div>
  <div id="editorForParameters" class="w3-sidebar w3-animate-left"
    style="z-index: 2; left: 0px; top: 0px; width: 25%;display: none; border-right: solid 2px black;">
    <div class="w3-block w3-yellow w3-hover-red w3-button" onclick="toggleSideBar('editorForParameters')">
      <div class="w3-right">
        <i class="fas fa-sign-out-alt fa-rotate-180"></i>
      </div>
      <div class="w3-left">
        Close
      </div>
    </div>
    <div v-if="!!cellModel.model">
      <div>
        <p class="w3-large" style="margin:0px;"><b>Connection name</b></p>
        <input class="w3-input w3-border w3-border-theme" v-model.trim="cellModel.value" type="text" />
        <div v-html="cellModel.value"></div>
      </div>
      <div class="w3-block w3-theme w3-hover-green w3-button" @click="applyCellValue">
        <div class="w3-right">
          <i class="fas fa-check"></i>
        </div>
        <div class="w3-left">
          Appy
        </div>
      </div>
    </div>
    <div v-else-if="!!uyamakModel">
      <div>
        <p class="w3-large" style="margin:0px;"><b>Block name</b></p>
        <input class="w3-input w3-border w3-border-theme" v-model.trim="uyamakModel.Name" type="text" />
        <div v-html="uyamakModel.Name"></div>
      </div>
      <div v-if="uyamakModel.TerminalsIn.editable">
        <p class="w3-large" style="margin:0px;">
          <b>Input terminals count</b>
        </p>
        <input class="w3-input w3-border w3-border-theme" v-model.number="uyamakModel.TerminalsIn.value" type="number"
          v-bind:min="uyamakModel.TerminalsIn.min" v-bind:max="uyamakModel.TerminalsIn.max" />
      </div>
      <div v-if="uyamakModel.TerminalsOut.editable">
        <p class="w3-large" style="margin:0px;">
          <b>Output terminals count</b>
        </p>
        <input class="w3-input w3-border w3-border-theme" v-model.number="uyamakModel.TerminalsOut.value" type="number"
          v-bind:min="uyamakModel.TerminalsOut.min" v-bind:max="uyamakModel.TerminalsOut.max" />
      </div>
      <div v-if="uyamakModel.Parameters.length>0">
        <p class="w3-large" style="margin:0px;"><b>Parameters</b></p>
        <template v-for="(Parameter, index) in uyamakModel.Parameters">
          <div class="w3-theme-d3 w3-border w3-border-theme w3-padding w3-ripple" @click="toggleParamDisplay(index)"
            style="cursor: pointer;">
            <span v-if="!!parametersDisplay[index]" :key="index+'_'+updatingCounter"><i
                class="fas fa-caret-down fa-fw"></i></span>
            <span v-else :key="index+'_'+updatingCounter"><i class="fas fa-caret-right fa-fw"></i></span>
            <span>{{ Parameter.Name }}</span>
          </div>
          <div v-if="!!parametersDisplay[index]">
            <div v-if="(Parameter.Dimension === 'Vector') || (Parameter.Dimension === 'Matrix')"
              class="w3-center w3-border-bottom w3-border-theme w3-theme-d1">
              <div @click="valueDimensionsModify(0, index)" style="width: 40px; height: 40px; padding:0px;" v-if=""
                class="w3-circle w3-button w3-theme-l3 w3-hover-theme w3-ripple w3-border w3-border-theme w3-display-container rotateNote">
                <div class="w3-display-middle">
                  <i class="fas fa-ellipsis-h"></i><i class="fas fa-plus-circle"></i>
                </div>
              </div>
              <div @click="valueDimensionsModify(1, index)" style="width: 40px; height: 40px; padding:0px;" v-if=""
                class="w3-circle w3-button w3-theme-l3 w3-hover-theme w3-ripple w3-border w3-border-theme w3-display-container rotateNote">
                <div class="w3-display-middle">
                  <i class="fas fa-ellipsis-h"></i><i class="fas fa-minus-circle fa-rotate-90"></i>
                </div>
              </div>
              <div v-if="(Parameter.Dimension === 'Matrix')" @click="valueDimensionsModify(2, index)"
                style="width: 40px; height: 40px; padding:0px;" v-if=""
                class="w3-circle w3-button w3-theme-l3 w3-hover-theme w3-ripple w3-border w3-border-theme w3-display-container">
                <div class="w3-display-middle">
                  <i class="fas fa-ellipsis-h"></i><i class="fas fa-plus-circle"></i>
                </div>
              </div>
              <div v-if="(Parameter.Dimension === 'Matrix')" @click="valueDimensionsModify(3, index)"
                style="width: 40px; height: 40px; padding:0px;" v-if=""
                class="w3-circle w3-button w3-theme-l3 w3-hover-theme w3-ripple w3-border w3-border-theme w3-display-container">
                <div class="w3-display-middle">
                  <i class="fas fa-ellipsis-h"></i><i class="fas fa-minus-circle"></i>
                </div>
              </div>
            </div>
            <div class="w3-responsive">
              <table class="w3-table-all">
                <template v-for="(rowValue, index1) in uyamakModel.Parameters[index]['Value']">
                  <tr v-if="(index1 === 0) && (Parameter.Dimension === 'Matrix')" style="padding: 0;">
                    <td class="w3-light-gray w3-border w3-border-theme"></td>
                    <template v-for="(value, index2) in uyamakModel.Parameters[index]['Value'][index1]">
                      <td style="padding:0;" class="w3-light-gray w3-center w3-border w3-border-theme">
                        {{ index2 + 1 }}
                      </td>
                    </template>
                  </tr>
                  <tr style="padding: 0;" class="w3-border-theme">
                    <td v-if="(Parameter.Dimension === 'Vector') || (Parameter.Dimension === 'Matrix')"
                      style="padding:0; vertical-align: middle;" class="w3-light-gray w3-border w3-border-theme">
                      {{ index1 + 1 }}
                    </td>
                    <template v-for="(value, index2) in uyamakModel.Parameters[index]['Value'][index1]">
                      <td style="padding: 0;" class="w3-border w3-border-theme">
                        <input v-if="(['Integer', 'Real', 'Complex', 'Text'].indexOf(Parameter.Type))>=0"
                          v-bind:class="(!validateParamCellEntry(index, index1, index2))? 'w3-red':''"
                          v-model.trim="uyamakModel.Parameters[index]['Value'][index1][index2]"
                          class="w3-input w3-border-0" style="padding: 0; min-width: 75px; padding: 8px 0px;"
                          v-bind:style="(Parameter.Type !== 'Text')?'text-align: right':''" type="text" />
                        <input v-if="Parameter.Type === 'Color'"
                          v-bind:class="(!validateParamCellEntry(index, index1, index2))? 'w3-red':''"
                          v-model.trim="uyamakModel.Parameters[index]['Value'][index1][index2]"
                          class="w3-input w3-border-0"
                          style="padding: 0; min-width: 75px; padding: 0px; min-height: 35px;"
                          v-bind:style="(Parameter.Type !== 'Text')?'text-align: right':''" type="color" />
                      </td>
                    </template>
                  </tr>
                </template>
              </table>
            </div>
          </div>
        </template>
      </div>
      <div>
        <template v-if="invalidInputs.length>0">
          <p class="w3-large" style="margin:0px;"><b>Input error(s)</b></p>
          <div v-html="inputErrors" class="w3-text-red"></div>
        </template>
        <template v-else-if="parametersValidationComments !== 'OK'">
          <p class="w3-large" style="margin:0px;">
            <b>Incompatable parameters</b>
          </p>
          <div v-html="parametersValidationComments"></div>
        </template>
        <template v-else>
          <p class="w3-large" style="margin:0px;"><b>Functionality</b></p>
          <div v-html="getBlockDetails()"></div>
          <div class="w3-button w3-ripple w3-lime w3-hover-green w3-bar w3-large" @click="saveModel()">
            <div class="w3-left">Apply</div>
            <div class="w3-right"><i class="far fa-save"></i></div>
          </div>
          <div class="w3-button w3-ripple w3-amber w3-hover-red w3-bar w3-large"
            onclick="changeEditModelWithSelectedBlock()">
            <div class="w3-left">Reset changes</div>
            <div class="w3-right"><i class="fas fa-undo-alt"></i></div>
          </div>
        </template>
      </div>
    </div>
    <div v-else>Select a block to edit its parameters.</div>
  </div>
  <div id="printingTheModel" class="w3-sidebar w3-animate-left"
    style="z-index: 2; left: 0px; top: 0px; width: 25%;display: none; border-right: solid 2px black;">
    <div class="w3-block w3-yellow w3-hover-red w3-button" onclick="toggleSideBar('printingTheModel')">
      <div class="w3-right">
        <i class="fas fa-sign-out-alt fa-rotate-180"></i>
      </div>
      <div class="w3-left">
        Close
      </div>
    </div>
    <select class="w3-select w3-border w3-border-theme" name="option" v-model="pageSize.value">
      <option v-for="(value, index) in pageSize.options" v-bind:value="index">{{ value }}</option>
    </select>
    <select class="w3-select w3-border w3-border-theme" name="option" v-model="orientation.value">
      <option v-for="(value, index) in orientation.options" v-bind:value="index">{{ value }}</option>
    </select>
    <label>Page title</label>
    <input class="w3-input w3-border w3-border-theme" v-model="title" type="text" />
    <input id="forcePages" class="w3-check" type="checkbox" checked="checked" v-model="fit.force" />
    <label for="forcePages">Scale the graph to fit in
      <input class="w3-input w3-border-theme w3-border-0" type="number" min="1" step="1"
        v-model.number="fit.numberOfPages" style="display:inline-flex; width:50px;" />
      page(s).</label>
    <div class="w3-block w3-theme w3-hover-red w3-button w3-large" @click="prepareMPDoc()">
      <div class="w3-right">
        <i class="fas fa-file-import"></i>
      </div>
      <div class="w3-left">
        Prepare document
      </div>
    </div>
  </div>

  <div id="app">
    <div id="waitForProcessToFinish" class="w3-modal w3-display-container">
      <div class="w3-display-middle w3-center w3-padding" style="background-color: rgba(255, 255, 255, 0.9);">
        <p id="DOMWaitingHead" class="w3-large"></p>
        <div class="fa-3x">
          <i class="fas fa-spinner fa-pulse"></i>
        </div>
        <p id="DOMWaitingDesc" class="w3-large"></p>
      </div>
    </div>

    <div class="w3-overlay w3-animate-opacity" onclick="closeLeftMenu()"
      style="cursor:pointer; position: fixed; left: 0px; top: 0px;" id="leftMenuOverlay"></div>
    <div class="w3-sidebar w3-card w3-animate-left"
      style="z-index: 2; left: 0px; top: 0px; width: 500px; max-width: 100%; display: none;" id="leftMenu"></div>
  </div>
  <div id="tempSideForAlwaysHidden" style="width:0px;"></div>
  <script>
    function prepareSVGURL(svg) {
      return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    }

    function toggleSideBar(sidebar = "tempSideForAlwaysHidden") {
      var thisSidebar = document.getElementById(sidebar);
      var allTheSidebars = document.getElementsByClassName("w3-sidebar");
      var currentStat = thisSidebar.style.display;
      var allTheMains = document.getElementsByClassName("umk_main");
      //console.log(allTheSidebars[0]);
      for (var i = 0; i < allTheSidebars.length; i++)
        allTheSidebars[i].style.display = "none";
      if (currentStat === "none") thisSidebar.style.display = "block";
      var sizeForMain = document.body.clientWidth - thisSidebar.clientWidth;
      for (var i = 0; i < allTheMains.length; i++) {
        allTheMains[i].style.width = sizeForMain + "px";
        allTheMains[i].style.marginLeft = thisSidebar.clientWidth + "px";
      }
      outln.refresh();
    }
  </script>

  <script>
    //MathJax setup
    MathJax.Hub.Config({
      showMathMenu: false,
      messageStyle: "none",
      menuSettings: {
        inTabOrder: false
      },
      extensions: ["tex2jax.js"],
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        preview: "none",
        inlineMath: [
          ["$", "$"],
          ["\\(", "\\)"]
        ],
        displayMath: [
          ["$$", "$$"],
          ["\\[", "\\]"]
        ]
      }
    });
  </script>
  <script>
    var notyf = new Notyf({
      duration: 10000
    });
  </script>
  <script>
    var printingTheModel = new Vue({
      el: "#printingTheModel",
      data: {
        addStartPages: [],
        addEndPages: [],
        title: "Uyamak model",
        orientation: {
          value: "portrait",
          options: {
            portrait: "Portrait",
            landscape: "Landscape"
          }
        },
        pageSize: {
          value: "letter",
          options: {
            letter: "Letter",
            a4: "A4"
          }
        },
        fit: {
          force: false,
          numberOfPages: 1
        }
      },
      methods: {
        prepareMPDoc: function () {
          graph.setSelectionCell();
          var scale = 1;
          this.fit.numberOfPages = Math.round(this.fit.numberOfPages);
          if (this.fit.numberOfPages < 1) this.fit.numberOfPages = 1;
          if (this.fit.force)
            scale = mxUtils.getScaleForPageCount(
              this.fit.numberOfPages,
              graph
            );
          var preview = new mxPrintPreview(graph, scale);
          preview.title = this.title;
          if (
            this.orientation.value === "portrait" &&
            this.pageSize.value === "letter"
          )
            preview.pageFormat = mxConstants.PAGE_FORMAT_LETTER_PORTRAIT;
          if (
            this.orientation.value === "portrait" &&
            this.pageSize.value === "a4"
          )
            preview.pageFormat = mxConstants.PAGE_FORMAT_A4_PORTRAIT;
          if (
            this.orientation.value === "landscape" &&
            this.pageSize.value === "letter"
          )
            preview.pageFormat = mxConstants.PAGE_FORMAT_LETTER_LANDSCAPE;
          if (
            this.orientation.value === "landscape" &&
            this.pageSize.value === "a4"
          )
            preview.pageFormat = mxConstants.PAGE_FORMAT_A4_LANDSCAPE;
          //console.log(preview.pageFormat);

          var defaultWriteHead = mxPrintPreview.prototype.writeHead;
          preview.writePostfix = function (doc) {
            defaultWriteHead.apply(this, arguments);
            doc.writeln(
              '<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"><\/script>'
            );
            doc.writeln("<script>");
            doc.writeln(
              'MathJax.Hub.Config({showMathMenu:false,messageStyle:"none",menuSettings:{inTabOrder:false},extensions:["tex2jax.js"],jax:["input/TeX","output/HTML-CSS"],tex2jax:{preview:"none",inlineMath:[["$","$"],["\\\\(","\\\\)"]],displayMath:[["\$\$","\$\$"],["\\\\[","\\\\]"]]}});'
            );
            doc.writeln("<\/script>");
            //return doc;
          };
          preview.open();
        }
      }
    });
  </script>
  <script>
    var editBlocksApp = new Vue({
      updated: function () {
        MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
      },
      el: "#editorForParameters",
      data: {
        uyamakModel: null,
        cellModel: {
          model: false,
          value: null
        },
        invalidInputs: [],
        parametersDisplay: null,
        updatingCounter: 0
      },
      computed: {
        parametersValidationComments: function () {
          return this.uyamakModel.ValidateParams();
        },
        inputErrors: function () {
          return (
            "<table class='w3-table'>" +
            this.invalidInputs
            .map(function (currentValue, index, arr) {
              return (
                "<tr><td>" +
                editBlocksApp.$data.uyamakModel.Parameters[
                  parseInt(currentValue.split(",")[0])
                ].Name +
                " at [" +
                (parseInt(currentValue.split(",")[1]) + 1) +
                ", " +
                (parseInt(currentValue.split(",")[2]) + 1) +
                "]" +
                "</td></tr>"
              );
            })
            .join("") +
            "</table>"
          );
        }
      },
      methods: {
        applyCellValue: function () {
          if (graph.getSelectionCell().isEdge() || graph.getSelectionCell().style === "group") {
            graph.getSelectionCell().value = this.cellModel.value;
            graph.refresh(graph.getSelectionCell());
          }
        },
        saveModel: function () {
          var editCell = graph.getSelectionCell();
          //Adjusting the number of input terminals
          this.uyamakModel.TerminalsIn.value = Math.floor(
            this.uyamakModel.TerminalsIn.value
          );
          if (
            !(
              this.uyamakModel.TerminalsIn.value >=
              this.uyamakModel.TerminalsIn.min &&
              this.uyamakModel.TerminalsIn.value <=
              this.uyamakModel.TerminalsIn.max
            )
          ) {
            if (
              this.uyamakModel.TerminalsIn.value >
              this.uyamakModel.TerminalsIn.max
            )
              this.uyamakModel.TerminalsIn.value = this.uyamakModel.TerminalsIn.max;
            else
              this.uyamakModel.TerminalsIn.value = this.uyamakModel.TerminalsIn.min;
          }
          if (
            this.uyamakModel.TerminalsIn.value !==
            editCell.value.TerminalsIn.value
          ) {
            //console.log(editCell);
            var dy = 1.0 / (this.uyamakModel.TerminalsIn.value + 1);
            var remainingTerminals = this.uyamakModel.TerminalsIn.value;
            var cellsToRemove = [];
            for (var i = 0; i < editCell.getChildCount(); i++) {
              if (editCell.children[i].geometry.x === 0) {
                if (remainingTerminals > 0) {
                  remainingTerminals--;
                  editCell.children[i].geometry.y =
                    dy *
                    (this.uyamakModel.TerminalsIn.value - remainingTerminals);
                } else cellsToRemove.push(editCell.children[i]);
              }
            }
            graph.removeCells(cellsToRemove);
            for (var i = 0; i < remainingTerminals; i++) {
              var p1 = graph.insertVertex(
                editCell,
                null,
                "$u_{" +
                (this.uyamakModel.TerminalsIn.value +
                  i -
                  remainingTerminals +
                  1) +
                "}(t)$",
                0,
                dy *
                (this.uyamakModel.TerminalsIn.value +
                  i -
                  remainingTerminals +
                  1),
                8,
                8,
                "constituent=1;fillColor=" +
                this.uyamakModel.Colors.bg +
                ";fontColor=" +
                this.uyamakModel.Colors.fg +
                ";strokeColor=" +
                this.uyamakModel.Colors.bg +
                ";labelPosition=right;labelWidth=80;align=left;shape=rectangle;portConstraint=west;shadow=0",
                true
              );
              p1.geometry.offset = new mxPoint(-8, -4);
            }
          }
          //Adjusting the number of input terminals
          this.uyamakModel.TerminalsOut.value = Math.floor(
            this.uyamakModel.TerminalsOut.value
          );
          if (
            !(
              this.uyamakModel.TerminalsOut.value >=
              this.uyamakModel.TerminalsOut.min &&
              this.uyamakModel.TerminalsOut.value <=
              this.uyamakModel.TerminalsOut.max
            )
          ) {
            if (
              this.uyamakModel.TerminalsOut.value >
              this.uyamakModel.TerminalsOut.max
            )
              this.uyamakModel.TerminalsOut.value = this.uyamakModel.TerminalsOut.max;
            else
              this.uyamakModel.TerminalsOut.value = this.uyamakModel.TerminalsOut.min;
          }
          if (
            this.uyamakModel.TerminalsOut.value !==
            editCell.value.TerminalsOut.value
          ) {
            //console.log(editCell);
            var dy = 1.0 / (this.uyamakModel.TerminalsOut.value + 1);
            var remainingTerminals = this.uyamakModel.TerminalsOut.value;
            var cellsToRemove = [];
            for (var i = 0; i < editCell.getChildCount(); i++) {
              if (editCell.children[i].geometry.x === 1) {
                if (remainingTerminals > 0) {
                  remainingTerminals--;
                  editCell.children[i].geometry.y =
                    dy *
                    (this.uyamakModel.TerminalsOut.value -
                      remainingTerminals);
                } else cellsToRemove.push(editCell.children[i]);
              }
            }
            graph.removeCells(cellsToRemove);
            for (var i = 0; i < remainingTerminals; i++) {
              var p1 = graph.insertVertex(
                editCell,
                null,
                "$y_{" +
                (this.uyamakModel.TerminalsOut.value +
                  i -
                  remainingTerminals +
                  1) +
                "}(t)$",
                1,
                dy *
                (this.uyamakModel.TerminalsOut.value +
                  i -
                  remainingTerminals +
                  1),
                8,
                16,
                "constituent=1;fillColor=" +
                this.uyamakModel.Colors.bg +
                ";fontColor=" +
                this.uyamakModel.Colors.fg +
                ";strokeColor=" +
                this.uyamakModel.Colors.bg +
                ";labelPosition=left;labelWidth=80;align=right;shape=triangle;portConstraint=east;shadow=0",
                true
              );
              p1.geometry.offset = new mxPoint(-0, -8);
            }
          }

          //Adding model to the Block
          eval(
            "var tempModel = new umk_" +
            this.uyamakModel.bid +
            "(this.uyamakModel);"
          );
          graph.getSelectionCell().setValue(tempModel);
          graph.refresh(graph.getSelectionCell());
        },
        getBlockDetails: function () {
          try {
            return this.uyamakModel.Details();
          } catch (e) {
            console.log(e);
            return "UNKNOWN ERROR!!!. If this error continues, please contact the support.";
          }
        },
        toggleParamDisplay: function (index) {
          //console.log(this.parametersDisplay);
          this.updatingCounter++;
          this.parametersDisplay[index] = !this.parametersDisplay[index];
        },
        validateParamCellEntry: function (index, index1, index2) {
          var tempValidateItem = index + "," + index1 + "," + index2;
          var outValue;
          var tempValue = this.uyamakModel.Parameters[index].Value[index1][
            index2
          ];
          try {
            switch (this.uyamakModel.Parameters[index].Type) {
              case "Integer":
                outValue =
                  typeof math.evaluate(tempValue) === "number" &&
                  math.evaluate(tempValue) % 1 === 0;
                break;
              case "Real":
                outValue = typeof math.evaluate(tempValue) === "number";
                break;
              case "Complex":
                outValue =
                  math.evaluate(tempValue).type === "Complex" ||
                  typeof math.evaluate(tempValue) === "number";
                break;
              case "Text":
              case "Color":
              case "Option":
                outValue = tempValue !== "" && tempValue !== null;
                break;
            }
          } catch (e) {
            console.log(e);
            outValue = false;
          }
          var tempIndex = this.invalidInputs.indexOf(tempValidateItem);
          if (outValue) {
            if (tempIndex >= 0) this.invalidInputs.splice(tempIndex, 1);
          } else {
            if (tempIndex < 0) this.invalidInputs.push(tempValidateItem);
          }
          return outValue;
        },
        valueDimensionsModify: function (func, index) {
          var tempItem;
          switch (this.uyamakModel.Parameters[index].Type) {
            case "Integer":
            case "Real":
            case "Complex":
              tempItem = 0;
              break;
            case "Text":
              tempItem = "";
              break;
            case "Color":
              tempItem = "Black";
              break;
          }
          switch (func) {
            case 0:
              this.uyamakModel.Parameters[index].Value.push(
                new Array(
                  this.uyamakModel.Parameters[index].Value[0].length
                ).fill(tempItem)
              );
              break;
            case 1:
              if (this.uyamakModel.Parameters[index].Value.length > 1)
                this.uyamakModel.Parameters[index].Value.pop();
              break;
            case 2:
              this.uyamakModel.Parameters[index].Value.map(function (val) {
                return val.push(tempItem);
              });
              break;
            case 3:
              if (this.uyamakModel.Parameters[index].Value[0].length > 1) {
                this.uyamakModel.Parameters[index].Value.map(function (val) {
                  return val.pop();
                });
              }
              break;
          }
          this.updatingCounter++;
        }
      }
    });
  </script>
  <script>
    function selectionChanged() {
      if (
        graph.getSelectionCell() &&
        graph.getSelectionCell().isVertex() &&
        typeof graph.getSelectionCell().value === "object"
      ) {
        changeEditModelWithSelectedBlock();
      } else {
        editBlocksApp.$set(editBlocksApp.$data, "uyamakModel", null);
        if (graph.getSelectionCell() && (graph.getSelectionCell().isEdge() || graph.getSelectionCell().style ===
            "group")) {
          editBlocksApp.$set(editBlocksApp.$data, "cellModel", {
            model: true,
            value: graph.getSelectionCell().value || ""
          });
        } else {
          editBlocksApp.$set(editBlocksApp.$data, "cellModel", {
            model: false,
            value: null
          });
        }
      }
    }

    function changeEditModelWithSelectedBlock() {
      eval(
        "var editModel = new umk_" +
        graph.getSelectionCell().value.bid +
        "(graph.getSelectionCell().value);"
      );
      editBlocksApp.$set(editBlocksApp.$data, "uyamakModel", editModel);
      editBlocksApp.$set(
        editBlocksApp.$data,
        "parametersDisplay",
        new Array(editModel.Parameters.length).fill(false)
      );
    }
  </script>

  <script>
    function holdToFinishAProcess(title = null, description = null) {
      if (title)
        document.getElementById("waitForProcessToFinish").style.display =
        "block";
      else
        document.getElementById("waitForProcessToFinish").style.display =
        "none";
      if (title) document.getElementById("DOMWaitingHead").innerText = title;
      if (description)
        document.getElementById("DOMWaitingDesc").innerText = description;
    }
    holdToFinishAProcess(
      "Connecting to the server.",
      "Please wait while loading the app. If this process takes longer than a minute, check your internet connection and refresh the page."
    );
  </script>
  <script>
    var TempRecAttempt;
    var functions = firebase.functions();
    var db = firebase.firestore();
    const settings = {
      timestampsInSnapshots: true
    };
    db.settings(settings);
    var validateUserSession = firebase
      .functions()
      .httpsCallable("validateUserSession");
    firebase.auth().onAuthStateChanged(function (user) {
      holdToFinishAProcess("Loading the app.");
      TempRecAttempt = setInterval(function () {
        //console.log("attempt");
        if (app) {
          holdToFinishAProcess("Verifying the license.");
          clearInterval(TempRecAttempt);
          user ? handleSignedInUser(user) : handleSignedOutUser();
        }
      }, 500);
    });

    function handleSignedInUser(user) {
      validateUserSession().then(function (result) {
        //console.log(result.data.isSuccess);
        if (result.data.isSuccess) loadTheGUI();
        else
          window.location.replace(
            "/platform/admin?redirect=" + location.pathname
          );
      });
    }

    function handleSignedOutUser() {
      window.location.replace("/sign-in?redirect=" + location.pathname);
    }

    function loadTheGUI() {
      //app.$set(app.$data.user, "uid", firebase.auth().currentUser.uid);
      /*app.$set(
        app.$data.user,
        "photoURL",
        firebase.auth().currentUser.photoURL
      );*/
      db.collection("blocks-summary")
        .get()
        .then(function (querySnapshot) {
          querySnapshot.forEach(function (doc) {
            db.collection("blocks-summary")
              .doc(doc.id)
              .get()
              .then(function (doc) {
                var dbData = doc.data();
                //console.log(doc.id, " => ", dbData);
                /*if (!app.$data.blocksSummary)
                  app.$set(app.$data, "blocksSummary", {});
                app.$set(app.$data.blocksSummary, doc.id, dbData);*/
                var headDiv = document.createElement("div");
                headDiv.classList.add("w3-theme-d2");
                headDiv.classList.add("w3-hover-blue");
                headDiv.style.cursor = "pointer";
                headDiv.innerHTML =
                  "<span><i class='fas fa-caret-down fa-fw'></i></span><span>" +
                  dbData.name +
                  "</span>";
                var bodyDiv = document.createElement("div");
                bodyDiv.style.display = "block";
                for (var key in dbData.blocks) {
                  addANewDraggableIcon(
                    bodyDiv,
                    Object.assign({
                        key: key,
                        colors: dbData.colors
                      },
                      dbData.blocks[key]
                    )
                  );
                }
                sortTheDoms(bodyDiv);
                var summDiv = document.createElement("div");
                summDiv.setAttribute(
                  "id",
                  "blocks_" + dbData.order + "for_" + doc.id
                );
                headDiv.addEventListener("click", function () {
                  if (bodyDiv.style.display === "block") {
                    bodyDiv.style.display = "none";
                    headDiv.firstElementChild.innerHTML =
                      "<i class='fas fa-caret-right fa-fw'></i>";
                  } else {
                    bodyDiv.style.display = "block";
                    headDiv.firstElementChild.innerHTML =
                      "<i class='fas fa-caret-down fa-fw'></i>";
                  }
                });
                summDiv.appendChild(headDiv);
                summDiv.appendChild(bodyDiv);
                document.getElementById("blocksBar").appendChild(summDiv);
                sortTheDoms(document.getElementById("blocksBar"));
              })
              .catch(function (error) {
                console.log("Error getting cached document:", error);
              });
          });
        });
      main(
        document.getElementById("modelContainer"),
        document.getElementById("outlineContainer")
      );
      holdToFinishAProcess(false);
    }

    function sortTheDoms(list) {
      var items = list.childNodes;
      var itemsArr = [];
      for (var i in items) {
        if (items[i].nodeType == 1) {
          // get rid of the whitespace text nodes
          itemsArr.push(items[i]);
        }
      }

      itemsArr.sort(function (a, b) {
        return a.id === b.id ? 0 : a.id > b.id ? 1 : -1;
      });

      for (i = 0; i < itemsArr.length; ++i) {
        list.appendChild(itemsArr[i]);
      }
    }

    var iconText = {
      icon1: "<svg viewBox='-3 -3 106 106' xmlns='http://www.w3.org/2000/svg'><defs><filter id='f0' x='-50%' y='-50%' width='200%' height='200%'><feGaussianBlur in='SourceAlpha' stdDeviation='1'/><feOffset dx='0' dy='0' result='offsetblur'/><feMerge><feMergeNode/><feMergeNode in='SourceGraphic'/></feMerge></filter><filter id='f1' x='-50%' y='-50%' width='200%' height='200%'><feOffset result='offOut' in='SourceAlpha' dx='3' dy='3' /><feGaussianBlur result='blurOut' in='offOut' stdDeviation='1' /><feBlend in='SourceGraphic' in2='blurOut' mode='normal' /></filter></defs><g><rect rx='20' height='100' width='100' y='0' x='0' stroke-width='0' fill='",
      icon2: "' filter='url(#f0)'/></g><g stroke-linecap='round' filter='url(#f1)' width='100' height='100' stroke='",
      icon3: "' stroke-width='10' fill='none'>",
      icon4: "</g></svg>"
    };

    function getIconWith(colors, path) {
      return (
        iconText.icon1 +
        colors.bg +
        iconText.icon2 +
        colors.fg +
        iconText.icon3 +
        path +
        iconText.icon4
      );
    }

    function svgTextToURL(svg) {
      svg = svg;
      let tempBlob = new Blob([svg], {
        type: "image/svg+xml"
      });
      let url = URL.createObjectURL(tempBlob);
      return url;
    }

    const blockTemplate = [{
        name: "Category",
        type: "string",
        argument: ""
      },
      {
        name: "Name",
        type: "string",
        argument: ""
      },
      {
        name: "Description",
        type: "string",
        argument: ""
      },
      {
        name: "Parameters",
        type: "json",
        argument: ""
      },
      {
        name: "Label",
        type: "function",
        argument: ""
      },
      {
        name: "Icon",
        type: "function",
        argument: ""
      },
      {
        name: "Init",
        type: "function",
        argument: ""
      },
      {
        name: "End",
        type: "function",
        argument: ""
      },
      {
        name: "Constructor",
        type: "function",
        argument: "Data"
      },
      {
        name: "Destructor",
        type: "function",
        argument: "Data"
      },
      {
        name: "RunTimeExec",
        type: "function",
        argument: ""
      },
      {
        name: "Evaluate",
        type: "function",
        argument: ""
      },
      {
        name: "Details",
        type: "function",
        argument: ""
      },
      {
        name: "ValidateParams",
        type: "function",
        argument: ""
      },
      {
        name: "bid",
        type: "string",
        argument: ""
      },
      {
        name: "Colors",
        type: "object",
        argument: ""
      },
      {
        name: "TerminalsIn",
        type: "object",
        argument: ""
      },
      {
        name: "TerminalsOut",
        type: "object",
        argument: ""
      }
    ];

    function loadABlock() {
      holdToFinishAProcess("Downloading the block from server");
      try {
        if (!BLOCKS_LIB || !BLOCKS_LIB[app.$data.bid]) {
          db.collection("blocks")
            .doc(app.$data.bid)
            .get()
            .then(function (doc) {
              holdToFinishAProcess("Loading block's functionaliy");
              if (doc.exists) {
                convertDBDataToModel(doc.id, doc.data());
                assignDataToNode(BLOCKS_LIB[app.$data.bid]);
              } else throw "Uyamak: Block Not found";
            });
        } else {
          assignDataToNode(BLOCKS_LIB[app.$data.bid]);
        }
      } catch (e) {
        console.log(e);
        GSK_CALLBACK(null);
        exitEditMode();
        holdToFinishAProcess(false);
        notyf.error("Error in adding this block.");
      }
    }

    function createIconForNetwork(cid, iconText) {
      return (
        "data:image/svg+xml;charset=utf-8," +
        encodeURIComponent(
          app.$data.networkIcon.icon1 +
          app.$data.blocksSummary[cid].colors.bg +
          app.$data.networkIcon.icon2 +
          app.$data.blocksSummary[cid].colors.fg +
          app.$data.networkIcon.icon3 +
          iconText +
          app.$data.networkIcon.icon4
        )
      );
    }

    function createCopyOfModel(inModel) {
      var outValue = JSON.parse2(JSON.stringify2(inModel));
      blockTemplate.forEach(function (item) {
        if (item.type === "function") {
          outValue[item.name] = inModel[item.name];
        }
      });
      return outValue;
    }

    function assignDataToNode(inModel) {
      GSK_DATA.uyamakModel = createCopyOfModel(inModel);
      GSK_DATA.uyamakModel.Constructor(GSK_DATA);
      var tempIconData = GSK_DATA.uyamakModel.Icon();
      GSK_DATA.shape = tempIconData.shape;
      if (GSK_DATA.shape === "image")
        GSK_DATA.image = createIconForNetwork(
          GSK_DATA.uyamakModel.Category,
          tempIconData.icon
        );
      else {
        var tempColors = app.getColorsForTheCategory();
        GSK_DATA.font = {
          color: tempColors.fg,
          background: tempColors.bg,
          face: "Courier New",
          size: 30
        };
      }
      GSK_DATA.label = GSK_DATA.uyamakModel.Label();
      GSK_DATA.title = GSK_DATA.uyamakModel.Details();
      GSK_CALLBACK(GSK_DATA);
      exitEditMode();
      holdToFinishAProcess(false);
    }

    function convertDBDataToModel(bid, dbBlockData) {
      BLOCKS_LIB[bid] = {};
      blockTemplate.forEach(function (item) {
        let tempObj = {};
        switch (item.type) {
          case "float":
            if (!dbBlockData[item.name]) tempObj[item.name] = 0;
            else tempObj[item.name] = parseFloat(dbBlockData[item.name]);
            Object.assign(BLOCKS_LIB[bid], tempObj);
            break;
          case "string":
            if (!dbBlockData[item.name]) tempObj[item.name] = "";
            else tempObj[item.name] = dbBlockData[item.name].toString();
            Object.assign(BLOCKS_LIB[bid], tempObj);
            break;
          case "function":
            if (!dbBlockData[item.name]) tempObj[item.name] = "";
            else tempObj[item.name] = dbBlockData[item.name].toString();
            tempObj[item.name] = eval(
              "(function (" +
              item.argument +
              "){" +
              dbBlockData[item.name] +
              "})"
            );
            Object.assign(BLOCKS_LIB[bid], tempObj);
            break;
          case "json":
            if (!dbBlockData[item.name]) tempObj[item.name] = [];
            else tempObj[item.name] = JSON.parse(dbBlockData[item.name]);
            Object.assign(BLOCKS_LIB[bid], tempObj);
            break;
        }
      });
    }

    function pullDBAndGenModel(bid) {
      return new Promise(function (resolve, reject) {
        if (eval("typeof umk_" + bid) === "function") {
          resolve();
        } else {
          db.collection("blocks")
            .doc(bid)
            .get()
            .then(function (doc) {
              if (doc.exists) {
                createAModel(doc.id, doc.data());
                resolve();
              }
            })
            .catch(function (e) {
              console.log(e);
              notyf.error(
                "Unable to load the block. If your internet connection is not a problem, please contact the support."
              );
              reject();
            });
        }
      });
    }

    function createAModel(bid, dbBlockData) {
      var constructorStr = "window.umk_" + bid + " = function(obj={}){";
      var prototypesStr = "";
      blockTemplate.forEach(function (item) {
        let tempObj = {};
        var tempVal;
        switch (item.type) {
          case "float":
            if (!dbBlockData[item.name]) tempVal = 0;
            else tempVal = parseFloat(dbBlockData[item.name]);
            constructorStr +=
              "this." + item.name + "=" + tempVal.toString() + ";";
            break;
          case "string":
            if (!dbBlockData[item.name]) tempVal = "";
            else tempVal = dbBlockData[item.name].toString();
            constructorStr +=
              "this." + item.name + '="' + tempVal.toString() + '";';
            break;
          case "json":
            //console.log(dbBlockData[item.name]);
            if (!dbBlockData[item.name]) tempVal = [];
            else tempVal = JSON.parse(dbBlockData[item.name]);
            constructorStr +=
              "this." + item.name + "=" + JSON.stringify(tempVal) + ";";
            break;
          case "object":
            if (!dbBlockData[item.name]) tempVal = {};
            else tempVal = dbBlockData[item.name];
            constructorStr +=
              "this." + item.name + "=" + JSON.stringify(tempVal) + ";";
            break;
          case "function":
            if (!dbBlockData[item.name]) tempVal = "";
            else tempVal = dbBlockData[item.name].toString();
            prototypesStr +=
              "\nwindow.umk_" +
              bid +
              ".prototype." +
              item.name +
              "=function(" +
              item.argument +
              "){" +
              tempVal +
              "}";
            break;
        }
      });
      constructorStr +=
        "for(var prop in obj){if (typeof obj[prop] !== 'function') this[prop] = JSON.parse2(JSON.stringify2(obj[prop]));}";
      constructorStr += "}";
      eval(constructorStr);
      eval(prototypesStr);
      //console.log(constructorStr);
    }
  </script>
  <script>
    function GetOrderOfExecution() {

    }

    function getAllTheModels() {
      var parent = graph.getDefaultParent();
      var allTheBlocks = [];
      if (graph.getDefaultParent().children) {
        allTheBlocks = allTheBlocks.concat(graph.getDefaultParent().children);
      }
      for (var i = 0; i < allTheBlocks.length; i++) {
        if (allTheBlocks[i].children) {
          allTheBlocks = allTheBlocks.concat(allTheBlocks[i].children);
        }
      }
      var allTheModels =[];
      for (var i=0;i<allTheBlocks.length; i++) {
        if (allTheBlocks[i].isVertex() && (typeof allTheBlocks[i].value =="object"))
        allTheModels.push(allTheBlocks[i]);
      }
      return allTheModels;
    }
    function getAllConnectedModels() {
      var parent = graph.getDefaultParent();
      var allTheBlocks = [];
      if (graph.getDefaultParent().children) {
        allTheBlocks = allTheBlocks.concat(graph.getDefaultParent().children);
      }
      for (var i = 0; i < allTheBlocks.length; i++) {
        if (allTheBlocks[i].children) {
          allTheBlocks = allTheBlocks.concat(allTheBlocks[i].children);
        }
      }
      var allTheValidEdges = [];
      for (var i=0;i<allTheBlocks.length; i++) {
        if (allTheBlocks[i].isEdge() && (typeof allTheBlocks[i].source.parent.value =="object") && (typeof allTheBlocks[i].target.parent.value =="object"))
        allTheValidEdges.push(allTheBlocks[i]);
      }
      var allConnectedBlocks = [];
      for (var i=0; i<allTheValidEdges.length; i++) {
        if (allConnectedBlocks.indexOf(allTheValidEdges[i].source.parent) < 0) {
          allConnectedBlocks.push(allTheValidEdges[i].source.parent);
        }
        if (allConnectedBlocks.indexOf(allTheValidEdges[i].target.parent) < 0) {
          allConnectedBlocks.push(allTheValidEdges[i].target.parent);
        }
      }
      return allConnectedBlocks;

    }
  </script>
</body>

</html>