var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { VALID_UNITS, } from './types';
import { findSupportedLocale, toObject, getOption, getParentLocaleHierarchy, supportedLocalesOf, } from '@formatjs/intl-utils';
/**
 * Find the correct field data in our CLDR data
 * Also merge with parent data since our CLDR is very packed
 * @param locale locale
 */
function findFields(locale) {
    var localeData = RelativeTimeFormat.__localeData__;
    var parentHierarchy = getParentLocaleHierarchy(locale);
    var dataToMerge = __spreadArrays([locale], parentHierarchy).map(function (l) { return localeData[l.toLowerCase()]; })
        .filter(Boolean);
    if (!dataToMerge.length) {
        throw new Error("Locale data added to RelativeTimeFormat is missing 'fields' for \"" + locale + "\"");
    }
    dataToMerge.reverse();
    return dataToMerge.reduce(function (all, d) { return (__assign(__assign({}, all), d.fields)); }, {});
}
function findFieldData(fields, unit, style) {
    if (style == 'long') {
        return fields[unit];
    }
    if (style == 'narrow') {
        return (fields[unit + "-narrow"] ||
            fields[unit + "-short"]);
    }
    return fields[unit + "-short"];
}
function objectIs(x, y) {
    if (Object.is) {
        return Object.is(x, y);
    }
    // SameValue algorithm
    if (x === y) {
        // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
    }
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
}
function resolvePastOrFuture(value) {
    return objectIs(value, -0)
        ? 'past'
        : objectIs(value, +0)
            ? 'future'
            : value < 0
                ? 'past'
                : 'future';
}
function validateInstance(instance, method) {
    if (!(instance instanceof RelativeTimeFormat)) {
        throw new TypeError("Method Intl.RelativeTimeFormat.prototype." + method + " called on incompatible receiver " + String(instance));
    }
}
function validateUnit(unit) {
    // `unit + ''` to guard against `Symbol()`
    if (!~VALID_UNITS.indexOf(unit + '')) {
        throw new RangeError("Invalid unit argument for format() '" + String(unit) + "'");
    }
    var resolvedUnit = (unit[unit.length - 1] === 's'
        ? unit.slice(0, unit.length - 1)
        : unit);
    return resolvedUnit;
}
function validateValue(value, method) {
    if (method === void 0) { method = 'format'; }
    var parsedValue = typeof value === 'string' ? new Number(value).valueOf() : value;
    if (!isFinite(parsedValue)) {
        throw new RangeError("Value need to be finite number for Intl.RelativeTimeFormat.prototype." + method + "()");
    }
    return parsedValue;
}
function isString(s) {
    return !!s;
}
var DEFAULT_LOCALE = new Intl.NumberFormat().resolvedOptions().locale;
var RelativeTimeFormat = /** @class */ (function () {
    function RelativeTimeFormat() {
        var _a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _a[_i] = arguments[_i];
        }
        var locales = _a[0], options = _a[1];
        // test262/test/intl402/RelativeTimeFormat/constructor/constructor/newtarget-undefined.js
        // Cannot use `new.target` bc of IE11 & TS transpiles it to something else
        var newTarget = this && this instanceof RelativeTimeFormat ? this.constructor : void 0;
        if (!newTarget) {
            throw new TypeError("Intl.RelativeTimeFormat must be called with 'new'");
        }
        var opts = options === undefined ? Object.create(null) : toObject(options);
        var localesToLookup = locales === undefined
            ? [DEFAULT_LOCALE]
            : __spreadArrays(Intl.NumberFormat.supportedLocalesOf(locales), [DEFAULT_LOCALE]);
        var resolvedLocale = findSupportedLocale(localesToLookup, RelativeTimeFormat.__localeData__);
        if (!resolvedLocale) {
            throw new Error("No locale data has been added to IntlRelativeTimeFormat for: " + localesToLookup.join(', '));
        }
        this._fields = findFields(resolvedLocale);
        this._localeMatcher = getOption(opts, 'localeMatcher', 'string', ['best fit', 'lookup'], 'best fit');
        this._style = getOption(opts, 'style', 'string', ['long', 'narrow', 'short'], 'long');
        this._numeric = getOption(opts, 'numeric', 'string', ['always', 'auto'], 'always');
        this._nf = new Intl.NumberFormat(locales);
        this._pl = new Intl.PluralRules(locales);
        this._numberingSystem = this._nf.resolvedOptions().numberingSystem;
    }
    RelativeTimeFormat.prototype.format = function (value, unit) {
        validateInstance(this, 'format');
        var resolvedUnit = validateUnit(unit);
        var parsedValue = validateValue(value);
        var _a = this, style = _a._style, numeric = _a._numeric;
        var fieldData = findFieldData(this._fields, resolvedUnit, style);
        if (!fieldData) {
            throw new Error("Unsupported unit " + unit);
        }
        var relative = fieldData.relative, relativeTime = fieldData.relativeTime;
        var result = '';
        // We got a match for things like yesterday
        if (numeric == 'auto' &&
            (result = relative[String(parsedValue)] || '')) {
            return result;
        }
        var selector = this._pl.select(parsedValue);
        var futureOrPastData = relativeTime[resolvePastOrFuture(parsedValue)];
        var msg = futureOrPastData[selector] || futureOrPastData.other;
        return msg.replace(/\{0\}/, this._nf.format(Math.abs(parsedValue)));
    };
    RelativeTimeFormat.prototype.formatToParts = function (value, unit) {
        validateInstance(this, 'format');
        var resolvedUnit = validateUnit(unit);
        var parsedValue = validateValue(value, 'formatToParts');
        var _a = this, style = _a._style, numeric = _a._numeric;
        var fieldData = findFieldData(this._fields, resolvedUnit, style);
        if (!fieldData) {
            throw new Error("Unsupported unit " + unit);
        }
        var relative = fieldData.relative, relativeTime = fieldData.relativeTime;
        var result = '';
        // We got a match for things like yesterday
        if (numeric == 'auto' &&
            (result = relative[String(parsedValue)] || '')) {
            return [
                {
                    type: 'literal',
                    value: result,
                },
            ];
        }
        var selector = this._pl.select(parsedValue);
        var futureOrPastData = relativeTime[resolvePastOrFuture(parsedValue)];
        var msg = futureOrPastData[selector] || futureOrPastData.other;
        var valueParts = this._nf
            .formatToParts(Math.abs(parsedValue))
            .map(function (p) { return (__assign(__assign({}, p), { unit: resolvedUnit })); });
        return msg
            .split(/(\{0\})/)
            .filter(isString)
            .reduce(function (parts, str) { return __spreadArrays(parts, (str === '{0}'
            ? valueParts
            : [{ type: 'literal', value: str }])); }, []);
    };
    RelativeTimeFormat.prototype.resolvedOptions = function () {
        validateInstance(this, 'resolvedOptions');
        // test262/test/intl402/RelativeTimeFormat/prototype/resolvedOptions/type.js
        var opts = Object.create(Object.prototype);
        Object.defineProperties(opts, {
            locale: {
                value: this._nf.resolvedOptions().locale,
                writable: true,
                enumerable: true,
                configurable: true,
            },
            style: {
                value: this._style.valueOf(),
                writable: true,
                enumerable: true,
                configurable: true,
            },
            numeric: {
                value: this._numeric.valueOf(),
                writable: true,
                enumerable: true,
                configurable: true,
            },
            numberingSystem: {
                value: this._numberingSystem.valueOf(),
                writable: true,
                enumerable: true,
                configurable: true,
            },
        });
        return opts;
    };
    RelativeTimeFormat.prototype.toString = function () {
        return '[object Intl.RelativeTimeFormat]';
    };
    RelativeTimeFormat.__addLocaleData = function () {
        var data = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            data[_i] = arguments[_i];
        }
        for (var _a = 0, data_1 = data; _a < data_1.length; _a++) {
            var datum = data_1[_a];
            if (!(datum && datum.locale)) {
                throw new Error('Locale data provided to RelativeTimeFormat is missing a ' +
                    '`locale` property value');
            }
            RelativeTimeFormat.__localeData__[datum.locale.toLowerCase()] = datum;
        }
    };
    RelativeTimeFormat.supportedLocalesOf = function (locales) {
        var _a = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            _a[_i - 1] = arguments[_i];
        }
        var opts = _a[0];
        // test262/test/intl402/RelativeTimeFormat/constructor/supportedLocalesOf/options-toobject.js
        var localeMatcher = 'best fit';
        // test262/test/intl402/RelativeTimeFormat/constructor/supportedLocalesOf/options-null.js
        if (opts === null) {
            throw new TypeError('opts cannot be null');
        }
        if (opts) {
            localeMatcher = getOption(opts, 'localeMatcher', 'string', ['best fit', 'lookup'], 'best fit');
        }
        // test262/test/intl402/RelativeTimeFormat/constructor/supportedLocalesOf/result-type.js
        return supportedLocalesOf(Intl.NumberFormat.supportedLocalesOf(locales, { localeMatcher: localeMatcher }), RelativeTimeFormat.__localeData__);
    };
    RelativeTimeFormat.__localeData__ = {};
    RelativeTimeFormat.polyfilled = true;
    return RelativeTimeFormat;
}());
export default RelativeTimeFormat;
